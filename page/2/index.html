<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  
    <meta name="keywords" content="iuu,jonah,哎呦呦,子非鱼安知鱼之乐">
  
  
    <meta name="description" content="子非鱼，安知鱼之乐。">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    
    iUU</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
</head>
</html>
<body>
<main class="content">
  <section class="jumbotron">
  <div class="video">
    
      <div class="video-frame">
        <img src="/images/ocean/overlay-hero.png" alt="Decorative image frame">
      </div>
    
    <div class="video-media">
      <video playsinline="" autoplay loop muted data-autoplay="" poster="/images/ocean/ocean.png" x5-video-player-type="h5">
        <source src="/images/ocean/ocean.mp4" type="video/mp4">
        <source src="/images/ocean/ocean.ogv" type="video/ogg">
        <source src="/images/ocean/ocean.webm" type="video/webm">
        <p>Your user agent does not support the HTML5 Video element.</p>
      </video>
      <div class="video-overlay"></div>
    </div>
    <div class="video-inner text-center text-white">
      <h1><a href="/">iUU</a></h1>
      <p>子非鱼，安知鱼之乐。</p>
      <div><img src="/images/hexo-inverted.svg" class="brand" alt="iUU"></div>
    </div>
    <div class="video-learn-more">
      <a class="anchor" href="#landingpage"><i class="fe fe-mouse"></i></a>
    </div>
  </div>
</section>

<div id="landingpage">
  <section class="outer">
  <article class="articles">
    
    <h1 class="page-type-title"></h1>

    
      
        <article id="post-survivorship" class="article article-type-post" itemscope="" itemprop="blogPost" data-scroll-reveal="">

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/survivorship/">幸存者偏差:你根本不了解这个真实世界</a>
    </h2>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/survivorship/" class="article-date">
  <time datetime="2017-09-17T05:40:21.000Z" itemprop="datePublished">2017-09-17</time>
</a>
        
  <div class="article-category">
    <a class="article-category-link" href="/categories/Moment/">Moment</a>
  </div>

      </div>
    

    <div class="article-entry" itemprop="articleBody">
      

      

      
        <p><img src="https://iuu.me/wp-content/uploads/2018/07/pix-300x223.jpg" alt=""> 今天跟大家分享一个非常非常重要的认知概念——幸存者偏差，又叫“死人不会说话”。这个概念也许重要到能够影响你的很多重大决策，并使你不容易被蠢蛋给忽悠。 <strong>一</strong> 在通读文章之前，先回答我几个问题： 1、如果你拥有李嘉诚的所有品质，你是否就能像他一样有钱？ 2、如果将你的大脑换成了巴菲特的，炒股是否就能无往而不利？ 3、如果乔布斯复生，但大家都不认识他，他是否能复制苹果王国的奇迹？ 我相信大部分人平时都想得到这些人的“超能力”，但如今作为一个问题提出来，他们会想一想，然后说，嗯，那可不一定。 每天都有数以亿计的人在商海中搏杀，以上无疑是最顶尖的几位，我们都被或多或少被安利过一些成功学的书籍，知道他们拥有高瞻远瞩的世界观，拥有独特迷人的性格特质，还拥有许多卓尔不凡的能力。 商业的漩涡里凶险异常，死在里面的不计其数，他们是少有的幸存者，如何解释幸存者是他们而不是别人呢？我们都想复制一个在自己身上，于是就从他们待人接物、为人处世的每一个小细节开始研究，恨不得连上厕所看不看报纸也成为重要的观察素材。 由于人与人之间终究不可能完全相同，于是我们就得出结论：看，怪不得我成不了他，原来他每天回家都要刷一遍鞋子，如此注重细节，真是窥一斑而知全貌，可想而知他在事业上肯定能做到尽善尽美。（同样的例子我还可以再举100个，如果他走路很快，我们会说怪不得他能成功，原来他是如此珍惜时间；如果他走路很慢，我们又会说怪不得他能成功，原来他走路都在思考问题） 这就是我们对于幸存者的“幸存者偏差”，我们都倾向于在幸存者身上寻找一些特质来说服自己每一位幸存者都绝非偶然，不然就无法解释“幸存者为何不能是我”这个问题。 之所以会存在这个偏差，是由于我们经常会想当然地选择样本。如果10万人里可以产生一位商业领袖，那么随着总群体的不断扩大，商业领袖的数量肯定会随之而增多，至于是什么让他们成为了领袖？我们就得将焦点注视在所有人身上，而不是这些幸存者个体。如果你这样做了，你很容易就会发现，这个社会上有成千上万拥有他们身上所有美好特质的人，但是他们穷困潦倒，身上也看不出一点点能成功的影子。 说得极端一些，如果将乔布斯再复制1000份，散落在世界各处，最后能成为幸存者的很可能也就只有一位，至于为什么是那位呢？因为他是第518位复制人啊，多牛的数字啊，上天注定的（人们总是能找到理由的，话说为什么不是第888位……）。 再举个例子：这个世界上有过很多“股神”，我说的是纯靠二级市场交易获利的那部分人，巴菲特并不算。如果把这些股神都集合在一起，算100个吧，一年收益为正的留下，收益为负的赶走，然后让这些股神随意买卖随意发挥，过了10年，应该会有那么几个“神中之神”被挑出来，他们会出书立传，写《炒股你该这么做》之类的“圣经”，并接受股民的膜拜。你会不会放心把钱交给他们打理呢？你肯定会说，那当然了，收再高的管理费我也愿意，那可是连续十年盈利的股神啊。 现在换一个场景，找100个押大小的，其中有个人鸿运当头已经连续押中了10轮，而且他告诉你他有一套复杂的计算公式，你会不会付他高额佣金拿钱让他去赌呢？你可能就会犹豫了，因为你会觉得那只是偶然，只要参与者基数够大，按照概率也总能产生几个连续盈利的人。既然如此，那你凭什么就会相信股神不是靠参与者基数够大而概率性产生的呢？那些数以万计比他更牛的人可能刚刚赔掉了裤衩。 “死人不会说话”——世界的关注点永远在那些偶然的成功者身上，却忽略了上万倍没被概率选中的失败者。 <strong>二</strong> 幸存者偏差现象普遍存在于我们的生活当中。 当你或你的亲人得病之时，是不是经常有人会适时出现，并一本正经地推荐给你一些非正规医院的老中医或者偏方？推荐完还不止，还斩钉截铁地告诉你，这个绝对好，绝对有用，我家的谁谁谁就是这么治好的。 抛却传统医学与现代医学之争，非正规医院的老中医或者偏方究竟有没有治好他的亲戚呢？假设他是一个诚实的人，那么是真的治好了，但老中医医治100个人，能治好几个这个数据他有没有呢？应该只有老中医自己才知道了。所有的幸存者都会认为，自己不会是人群中特别幸运的那部分人，因此，他们会在未拿全样本之前就认为这位老中医或者这剂偏方非常有效，并不遗余力地主动宣传。 这种事情在教育程度落后的地区发生的概率更大一些，所以跟迷信一样，大师通常都“隐居”在“世外桃源”，因为那里的人更容易受到蒙蔽。 由于家中亲戚人口众多，在我小的时候，这并不是什么新鲜事。家中谁得了病，总有一大帮人热情地过来推荐，但每个人只笃信自己的那个大师或那剂偏方。就我的记忆来看，只有一两次有人通过这种方式痊愈了，但第二次去也都不灵了，然而，深信的人却依旧深信不疑。 为何这种“祖传偏方”基本都是不靠谱的呢？很简单，如果它真的具有普适性和不可替代性，经过几十年上百年，它就不会只是偏方了。 为何在这一点上，“幸存者偏差”表现得比较明显呢？也很简单，因为对于偏方，我们的期待值总是较低的。事实上，我们对医院的信赖度还是较高的，我们默认医院的治疗是100分，如果它的治疗效果最后是90分，你就会很不满意，认为这家医院不行；但对于偏方就不一样了，我们抱着试试看的想法，心理预期一般都只有20分，如果假设它真的有点用，达到了50分的效果，你对它的疗效就会非常满意，且很容易默认它对所有人均有效。何解？跟吹牛的原理差不多，每个人都希望在他人面前提升自己的价值感，其中一个体现就是你可以为他人提供独到的价值信息，而医院就在那儿，好不好一查就知，推荐就不如偏方这样具备价值独有性了。 “死人不会说话”——只有治好的人才认为自己找到了救星，并且印象非常深刻，乃至于费力地主动宣传。那些数倍乃至数十倍治不好的人会即时转向下一位“神医”，并将当下这位快速遗忘，他们是一群数量庞大的“沉默者”，因此，除非某位“神医”或“某个方子”一个人都治不好，否则，他（它）总会受到追捧。 <strong>三</strong> 我们的大脑本身是有理性的，但在很多事情上，由于我们将规避危险的系统人为地放大，就容易暂时性地丢失理性，如牛一般被牵着鼻子走，以至于完全感知不到我们正在掉入“幸存者偏差”的陷阱之中。 犹记得“马航MH370事件”出了以后，铺天盖地的媒体宣传持续了好几个月，我妈本来打算去云南的都不敢去了，听说我近期要出去外面两趟，跟我说了好几次让我改期的事儿，说飞机实在太危险了，飞着飞着就没了。 事实上，我们都知道，飞机是最安全的交通工具，是的，按出行里程来算的话，它比火车更安全。哪怕你是一位每天都要坐一趟飞机的“空中飞人”，也需要上万年才会遇到一次重大事故，注意，还不是致死事故，且要碰到一次这样的事故，你的飞行距离大概平均得达到地球到太阳距离的十几倍才行。 很多人现在已经逐渐明白了飞机的安全性，但他们还是认为，虽然飞机的事故率极低，但一旦出事就无法幸免，这同样是掉入了陷阱之中，事实上，飞机事故后的生还率在90%以上，这可能会颠覆你的三观，但这就是事实。 而汽车呢？随着私家车保有量的节节增长，我们的道路交通事故死亡人数也节节攀高（别相信交通管理局的官方数据，你懂的，这个数据跟我国自己的卫生部门数据都差好几倍，别提世卫组织手上的数据了），如今大概数字已经超过了20万人/年，注意，这是死亡人数，而非事故数，这是个比雾霾严重得多得多的生死存亡的大问题。 然而，这并不妨碍许多人依然患有飞机恐惧症，却对私家车出行有着足够的心理安全感，甚至还在网上购买安全带扣，只为了能省去系安全带的麻烦，这一切都源于关注点仅仅落在媒体报道的原因。 同样的还有地沟油、黑心作坊、国产奶粉等食品安全问题，我听到许多人都在感叹，现在真是什么都不能吃了。是的，的确有一些黑心商人，为了利益不择手段，但你得明白，这些仍然不足以成为普遍现象，你的焦点永远都在那几家有问题的商家上，然后就开始自行脑补，因为你根本不知道总的体量有多大。如果你硬要感叹现在的商家越来越黑心，我倒是认为，恰恰相反。这事儿出的越多，证明市场剩下的安全系数越高，为啥？因为有人暗访了、有人曝光了、有人管了，才会给其他人起到一些警示作用，你以为歌舞升平、一片赞好就是真好呢？都说中国人造的桥是豆腐渣工程，那你们家门口的塌过没有？ 请各位记住，稀松平常的事情，媒体是没有兴趣报道的，因此，见诸报端或荧幕的事情一定是个案，你需要提防的重点永远都不应该在那里，因为你会更容易死在一些看起来平凡的事情上。 “死人不会说话”——车祸死个人太正常，如果不是有其他料，媒体不会报道；食品吃了没事太正常，媒体不会报道；桥正常使用也太正常，媒体也不会报道。 <strong>四</strong> 最近10年，选秀一直是歌手孵化的最大阵地，很多“有梦想”的年轻人看到以后，就抛弃一切四处参加选秀，希望有朝一日自己也可以像那些前辈一样功成名就。 当然这种精神绝对是值得鼓励的，没有奋不顾身的勇气，如何会有盆满钵满的收获？但你得打心眼儿里清楚一件事情，哪怕选秀孵化了再多的歌手，死在你前面的比你有才又努力的“前辈”依然是多得超过你的想象。 任贤齐，当年凭借一首“心太软”开始红遍大江南北。据他本人透露，当年有几十首作品寄给了唱片公司，《心太软》也是其中之一。唱片公司在审核的时候，本来已经将这首歌“丢进垃圾桶”，但由于最后没有找到心仪的歌曲，就在回去翻找的时候翻出了这首“遗珠”，连他们自己都想不到，最后竟然会如此之火。 这是一个励志的故事，你当然可以说出“机会是垂青有准备的人”、“有志者事竟成”之类的冠冕堂皇的话，但事实是，有成百上千的“任贤齐”现在早已远离“歌手”这个职业，他们可能正开着一家小店，也可能正在工地搬砖。当你被现实撞得头破血流，你终究会明白，大多数情况下，就算你再有天赋再努力，你的作品也不会刚好被往回找遗珠的唱片公司所青睐。 最后以2000多年前罗马的思想家西塞罗讲的故事结尾： 有人把一幅画给一位无神论者看，画上画着一群正在祈祷拜神的人，并告诉他，这些人在随后的沉船事故中都活了下来。 无神论者淡淡一问：我想看看那些祈祷完被淹死的人的画像在哪儿？ 因为“死人不会说话”。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://iuu.me/survivorship/" data-id="cjvp22zz7000wsomh1si200b2" class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Silent-data/">Silent data</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/died-man-can-t-talk/">died man can't talk</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/survivorship-bias/">survivorship bias</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
        <article id="post-battleye-bypass" class="article article-type-post" itemscope="" itemprop="blogPost" data-scroll-reveal="">

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/battleye-bypass/">Battleye bypass</a>
    </h2>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/battleye-bypass/" class="article-date">
  <time datetime="2017-08-04T01:10:42.000Z" itemprop="datePublished">2017-08-04</time>
</a>
        
  <div class="article-category">
    <a class="article-category-link" href="/categories/Code/">Code</a>
  </div>

      </div>
    

    <div class="article-entry" itemprop="articleBody">
      

      

      
        <p><img src="https://iuu.me/wp-content/uploads/2018/07/bypass-300x225.jpg" alt=""> BE，国外知名的ring0级别的反作弊保护系统，跟国内小马哥的TP差不多，被保护的程序。将无法进行读写内存等操作，又不给读又不给写那不变成了盲人摸象。而且BE的监察力度很大，ring0级别的驱动也同样会被检测。当BE检测到OpenProcess对受保护进程的调用就会重点关注你接下来的一言一行，如果继续去试图读取受保护进程的内存，直接就会被记录在案，延缓执行GLOBE BAN。 膜拜striek和MarkHC两位大佬提供的bypass的新思路：CPU-Z驱动程序允许用户直接读写物理内存，你可以首先尝试启动一个低访问的句柄，在你需要的时候直接通过内核对象操作提升句柄权限。LoadLibrary劫持受保护的进程来做你想做的事儿。 实测Bypass on PUBG 实例： CPUZ Dirver:</p>
<ol>
<li><p>using System;    </p>
</li>
<li><p>using System.Collections.Generic;    </p>
</li>
<li><p>using System.IO;    </p>
</li>
<li><p>using System.Linq;    </p>
</li>
<li><p>using System.Runtime.InteropServices;    </p>
</li>
<li><p>using System.Text;    </p>
</li>
<li><p>using System.Threading;    </p>
</li>
<li><p>using System.Threading.Tasks;    </p>
</li>
<li><p>namespace DriverExploits    </p>
</li>
<li><p>{    </p>
</li>
<li><p>publicunsafeclass CPUZ    </p>
</li>
<li><p>{    </p>
</li>
<li><p>privateconststring DriverDisplayName = “cpuz141”;    </p>
</li>
<li><p>privateconststring DriverFileName = “C:\\Windows\\System32\\drivers\\cpuz141.sys”;    </p>
</li>
<li><p>privateconststring DriverDeviceName = “\\Device\\cpuz141”;    </p>
</li>
<li><p>privateconstuint IOCTL_ReadControlRegister = 0x9C402428;    </p>
</li>
<li><p>privateconstuint IOCTL_ReadPhysicalAddress = 0x9C402420;    </p>
</li>
<li><p>privateconstuint IOCTL_WritePhysicalAddress = 0x9C402430;    </p>
</li>
<li><p>private IntPtr g_ServiceHandle;    </p>
</li>
<li><p>private IntPtr g_DeviceHandle;    </p>
</li>
<li><p>#region Memory Structs  </p>
</li>
<li><p>[StructLayout(LayoutKind.Sequential)]    </p>
</li>
<li><p>struct InputReadStruct    </p>
</li>
<li><p>{    </p>
</li>
<li><p>publicuint AddressHigh;    </p>
</li>
<li><p>publicuint AddressLow;    </p>
</li>
<li><p>publicuint Length;    </p>
</li>
<li><p>publicuint BufferHigh;    </p>
</li>
<li><p>publicuint BufferLow;    </p>
</li>
<li><p>};    </p>
</li>
<li><p>[StructLayout(LayoutKind.Sequential)]    </p>
</li>
<li><p>struct InputWriteStruct    </p>
</li>
<li><p>{    </p>
</li>
<li><p>publicuint AddressHigh;    </p>
</li>
<li><p>publicuint AddressLow;    </p>
</li>
<li><p>publicuint Value;    </p>
</li>
<li><p>};    </p>
</li>
<li><p>[StructLayout(LayoutKind.Sequential)]    </p>
</li>
<li><p>struct OutputStruct    </p>
</li>
<li><p>{    </p>
</li>
<li><p>publicuint Operation;    </p>
</li>
<li><p>publicuint BufferLow;    </p>
</li>
<li><p>};    </p>
</li>
<li><p>#endregion  </p>
</li>
<li><p>// DRIVER FUNCTIONS  </p>
</li>
<li><p>/// <summary>  </summary></p>
</li>
<li><p>/// Load the vulnerable driver  </p>
</li>
<li><p>///   </p>
</li>
<li><p>/// <returns></returns>  </p>
</li>
<li><p>publicbool Load()    </p>
</li>
<li><p>{    </p>
</li>
<li><p>IntPtr serviceHandle;    </p>
</li>
<li><p>if (ServiceHelper.OpenService(out serviceHandle, DriverDisplayName, 0x0020/*SERVICE_STOP*/ | 0x00010000/*DELETE*/))    </p>
</li>
<li><p>{    </p>
</li>
<li><p>Console.WriteLine($“[!] Service already running”);    </p>
</li>
<li><p>if (!ServiceHelper.StopService(serviceHandle))    </p>
</li>
<li><p>Console.WriteLine($“[!] Couldn’t stop service”);    </p>
</li>
<li><p>if (!ServiceHelper.DeleteService(serviceHandle))    </p>
</li>
<li><p>Console.WriteLine($“[!] Couldn’t delete service”);    </p>
</li>
<li><p>ServiceHelper.CloseServiceHandle(serviceHandle);    </p>
</li>
<li><p>return Load();    </p>
</li>
<li><p>}    </p>
</li>
<li><p>File.WriteAllBytes(DriverFileName, CPUZShellcode.Shellcode);    </p>
</li>
<li><p>Console.WriteLine($“[+] Loading…”);    </p>
</li>
<li><p>if (!ServiceHelper.CreateService(    </p>
</li>
<li><p>ref g_ServiceHandle,    </p>
</li>
<li><p>DriverDisplayName, DriverDisplayName,    </p>
</li>
<li><p>DriverFileName,    </p>
</li>
<li><p>(uint)Nt.SERVICE_ACCESS.SERVICE_ALL_ACCESS, 1/*SERVICE_KERNEL_DRIVER*/,    </p>
</li>
<li><p>(uint)Nt.SERVICE_START.SERVICE_DEMAND_START, 1/*SERVICE_ERROR_NORMAL*/))    </p>
</li>
<li><p>{    </p>
</li>
<li><p>Console.WriteLine($“[!] Failed to create service – {Marshal.GetLastWin32Error():X}”);    </p>
</li>
<li><p>returnfalse;    </p>
</li>
<li><p>}    </p>
</li>
<li><p>if (!ServiceHelper.StartService(g_ServiceHandle))    </p>
</li>
<li><p>{    </p>
</li>
<li><p>Console.WriteLine($“[!] Failed to start service – {Marshal.GetLastWin32Error():X}”);    </p>
</li>
<li><p>ServiceHelper.DeleteService(g_ServiceHandle);    </p>
</li>
<li><p>returnfalse;    </p>
</li>
<li><p>}    </p>
</li>
<li><p>Console.WriteLine($“[+] Getting Device Handle”);    </p>
</li>
<li><p>Nt.OBJECT_ATTRIBUTES objectAttributes = new Nt.OBJECT_ATTRIBUTES();    </p>
</li>
<li><p>Nt.UNICODE_STRING deviceName = new Nt.UNICODE_STRING(DriverDeviceName);    </p>
</li>
<li><p>Nt.IO_STATUS_BLOCK ioStatus;    </p>
</li>
<li><p>objectAttributes.Length = Marshal.SizeOf(typeof(Nt.OBJECT_ATTRIBUTES));    </p>
</li>
<li><p>objectAttributes.ObjectName = new IntPtr(&amp;deviceName);    </p>
</li>
<li><p>uint status = 0;    </p>
</li>
<li><p>IntPtr deviceHandle;    </p>
</li>
<li><p>do</p>
</li>
<li><p>{    </p>
</li>
<li><p>status = Nt.NtOpenFile(    </p>
</li>
<li><p>&amp;deviceHandle,    </p>
</li>
<li><p>(uint)(Nt.ACCESS_MASK.GENERIC_READ | Nt.ACCESS_MASK.GENERIC_WRITE | Nt.ACCESS_MASK.SYNCHRONIZE),    </p>
</li>
<li><p>&amp;objectAttributes, &amp;ioStatus, 0, 3/*OPEN_EXISTING*/);    </p>
</li>
<li><p>if (status != 0/*NT_SUCCESS*/)    </p>
</li>
<li><p>{    </p>
</li>
<li><p>Console.WriteLine($“[!] NtOpenFile failed! – {status:X}”);    </p>
</li>
<li><p>Thread.Sleep(250);    </p>
</li>
<li><p>}    </p>
</li>
<li><p>} while (status != 0/*NT_SUCCESS*/);    </p>
</li>
<li><p>g_DeviceHandle = deviceHandle;    </p>
</li>
<li><p>Console.WriteLine($“[+] hService: {g_ServiceHandle:X}”);    </p>
</li>
<li><p>Console.WriteLine($“[+] hDevice: {g_DeviceHandle:X}”);    </p>
</li>
<li><p>returntrue;    </p>
</li>
<li><p>}    </p>
</li>
<li><p>/// <summary>  </summary></p>
</li>
<li><p>/// Unload the vulnerable driver (and clean up its mess)  </p>
</li>
<li><p>///   </p>
</li>
<li><p>/// <returns></returns>  </p>
</li>
<li><p>publicbool Unload()    </p>
</li>
<li><p>{    </p>
</li>
<li><p>if (!ServiceHelper.StopService(g_ServiceHandle))    </p>
</li>
<li><p>{    </p>
</li>
<li><p>Console.WriteLine($“[!] Couldn’t stop service”);    </p>
</li>
<li><p>returnfalse;    </p>
</li>
<li><p>}    </p>
</li>
<li><p>if (!ServiceHelper.DeleteService(g_ServiceHandle))    </p>
</li>
<li><p>{    </p>
</li>
<li><p>Console.WriteLine($“[!] Couldn’t delete service”);    </p>
</li>
<li><p>returnfalse;    </p>
</li>
<li><p>}    </p>
</li>
<li><p>ServiceHelper.CloseServiceHandle(g_ServiceHandle);    </p>
</li>
<li><p>Nt.CloseHandle(g_DeviceHandle);    </p>
</li>
<li><p>Console.WriteLine($“[+] Unloaded service”);    </p>
</li>
<li><p>returntrue;    </p>
</li>
<li><p>}    </p>
</li>
<li><p>// HELPERS  </p>
</li>
<li><p>privateulong LODWORD(ulong l) =&gt; (l &amp; 0xffffffff);    </p>
</li>
<li><p>privateulong HIDWORD(ulong l) =&gt; ((l &gt;&gt; 32) &amp; 0xffffffff);    </p>
</li>
<li><p>/* I HAVE NO FUCKING CLUE – BLINDLY TRUST MARK  </p>
</li>
<li><ul>
<li>[8:13 PM] markhc: <a href="https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-system-programming-manual-325384.pdf" target="_blank" rel="noopener">https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-system-programming-manual-325384.pdf</a>  </li>
</ul>
</li>
<li><ul>
<li>[8:13 PM] markhc: chapter 4  </li>
</ul>
</li>
<li><ul>
<li>[8:14 PM] markhc: Figure 4-8. Linear-Address Translation to a 4-KByte Page using IA-32e Paging  </li>
</ul>
</li>
<li><p>*/</p>
</li>
<li><p>publiculong TranslateLinearAddress(ulong directoryTableBase, ulong virtualAddress)    </p>
</li>
<li><p>{    </p>
</li>
<li><p>ushort PML4 = (ushort)((virtualAddress &gt;&gt; 39) &amp; 0x1FF);         //&lt;! PML4 Entry Index  </p>
</li>
<li><p>ushort DirectoryPtr = (ushort)((virtualAddress &gt;&gt; 30) &amp; 0x1FF); //&lt;! Page-Directory-Pointer Table Index  </p>
</li>
<li><p>ushort Directory = (ushort)((virtualAddress &gt;&gt; 21) &amp; 0x1FF);    //&lt;! Page Directory Table Index  </p>
</li>
<li><p>ushort Table = (ushort)((virtualAddress &gt;&gt; 12) &amp; 0x1FF);        //&lt;! Page Table Index  </p>
</li>
<li><p>// Read the PML4 Entry. DirectoryTableBase has the base address of the table.  </p>
</li>
<li><p>// It can be read from the CR3 register or from the kernel process object.  </p>
</li>
<li><p>ulong PML4E = ReadPhysicalAddress<ulong>(directoryTableBase + (ulong)PML4 * sizeof(ulong));    </ulong></p>
</li>
<li><p>if (PML4E == 0)    </p>
</li>
<li><p>return 0;    </p>
</li>
<li><p>// The PML4E that we read is the base address of the next table on the chain,  </p>
</li>
<li><p>// the Page-Directory-Pointer Table.  </p>
</li>
<li><p>ulong PDPTE = ReadPhysicalAddress<ulong>((PML4E &amp; 0xFFFF1FFFFFF000) + (ulong)DirectoryPtr * sizeof(ulong));    </ulong></p>
</li>
<li><p>if (PDPTE == 0)    </p>
</li>
<li><p>return 0;    </p>
</li>
<li><p>//Check the PS bit  </p>
</li>
<li><p>if ((PDPTE &amp; (1 &lt;&lt; 7)) != 0)    </p>
</li>
<li><p>{    </p>
</li>
<li><p>// If the PDPTE’s PS flag is 1, the PDPTE maps a 1-GByte page. The  </p>
</li>
<li><p>// final physical address is computed as follows:  </p>
</li>
<li><p>// — Bits 51:30 are from the PDPTE.  </p>
</li>
<li><p>// — Bits 29:0 are from the original va address.  </p>
</li>
<li><p>return (PDPTE &amp; 0xFFFFFC0000000) + (virtualAddress &amp; 0x3FFFFFFF);    </p>
</li>
<li><p>}    </p>
</li>
<li><p>// PS bit was 0. That means that the PDPTE references the next table  </p>
</li>
<li><p>// on the chain, the Page Directory Table. Read it.  </p>
</li>
<li><p>ulong PDE = ReadPhysicalAddress<ulong>((PDPTE &amp; 0xFFFFFFFFFF000) + (ulong)Directory * sizeof(ulong));    </ulong></p>
</li>
<li><p>if (PDE == 0)    </p>
</li>
<li><p>return 0;    </p>
</li>
<li><p>if ((PDE &amp; (1 &lt;&lt; 7)) != 0)    </p>
</li>
<li><p>{    </p>
</li>
<li><p>// If the PDE’s PS flag is 1, the PDE maps a 2-MByte page. The  </p>
</li>
<li><p>// final physical address is computed as follows:  </p>
</li>
<li><p>// — Bits 51:21 are from the PDE.  </p>
</li>
<li><p>// — Bits 20:0 are from the original va address.  </p>
</li>
<li><p>return (PDE &amp; 0xFFFFFFFE00000) + (virtualAddress &amp; 0x1FFFFF);    </p>
</li>
<li><p>}    </p>
</li>
<li><p>// PS bit was 0. That means that the PDE references a Page Table.  </p>
</li>
<li><p>ulong PTE = ReadPhysicalAddress<ulong>((PDE &amp; 0xFFFFFFFFFF000) + (ulong)Table * sizeof(ulong));    </ulong></p>
</li>
<li><p>if (PTE == 0)    </p>
</li>
<li><p>return 0;    </p>
</li>
<li><p>// The PTE maps a 4-KByte page. The  </p>
</li>
<li><p>// final physical address is computed as follows:  </p>
</li>
<li><p>// — Bits 51:12 are from the PTE.  </p>
</li>
<li><p>// — Bits 11:0 are from the original va address.  </p>
</li>
<li><p>return (PTE &amp; 0xFFFFFFFFFF000) + (virtualAddress &amp; 0xFFF);    </p>
</li>
<li><p>}    </p>
</li>
<li><p>/// <summary>  </summary></p>
</li>
<li><p>/// Read a kernel control register  </p>
</li>
<li><p>///   </p>
</li>
<li><p>/// <returns>Value of control register</returns>  </p>
</li>
<li><p>publiculong ReadControlRegister(uint controlRegister)    </p>
</li>
<li><p>{    </p>
</li>
<li><p>ulong value = 0;    </p>
</li>
<li><p>ulong io = 0;    </p>
</li>
<li><p>if (!Nt.DeviceIoControl(g_DeviceHandle, IOCTL_ReadControlRegister, &amp;controlRegister, sizeof(uint), &amp;value, sizeof(ulong), &amp;io, 0))    </p>
</li>
<li><p>thrownew Exception(“DeviceIonControl failed! – 0x9C402428”);    </p>
</li>
<li><p>return value;    </p>
</li>
<li><p>}    </p>
</li>
<li><p>/// <summary>  </summary></p>
</li>
<li><p>/// Read buffer, of specified size, at physical address  </p>
</li>
<li><p>///   </p>
</li>
<li><p>/// <returns>Success</returns>  </p>
</li>
<li><p>publicbool ReadPhysicalAddress(ulong lpAddress, ulong lpBuffer, ulong lLength)    </p>
</li>
<li><p>{    </p>
</li>
<li><p>InputReadStruct input = new InputReadStruct();    </p>
</li>
<li><p>OutputStruct output = new OutputStruct();    </p>
</li>
<li><p>if (lpAddress == 0 || lpBuffer == 0)    </p>
</li>
<li><p>returnfalse;    </p>
</li>
<li><p>input.AddressHigh = (uint)HIDWORD(lpAddress);    </p>
</li>
<li><p>input.AddressLow = (uint)LODWORD(lpAddress);    </p>
</li>
<li><p>input.Length = (uint)lLength;    </p>
</li>
<li><p>input.BufferHigh = (uint)HIDWORD(lpBuffer);    </p>
</li>
<li><p>input.BufferLow = (uint)LODWORD(lpBuffer);    </p>
</li>
<li><p>ulong io = 0;    </p>
</li>
<li><p>return Nt.DeviceIoControl(g_DeviceHandle, IOCTL_ReadPhysicalAddress, &amp;input, (uint)Marshal.SizeOf(typeof(InputReadStruct)), &amp;output, (uint)Marshal.SizeOf(typeof(OutputStruct)), &amp;io, 0);    </p>
</li>
<li><p>}    </p>
</li>
<li><p>/// <summary>  </summary></p>
</li>
<li><p>/// Write buffer, of specified size, at physical address  </p>
</li>
<li><p>///   </p>
</li>
<li><p>/// <returns>Success</returns>  </p>
</li>
<li><p>publicbool WritePhysicalAddress(ulong address, ulong buf, ulong len)    </p>
</li>
<li><p>{    </p>
</li>
<li><p>if (len % 4 != 0 || len == 0)    </p>
</li>
<li><p>thrownew Exception(“The CPU-Z driver can only write lengths that are aligned to 4 bytes (4, 8, 12, 16, etc)”);    </p>
</li>
<li><p>InputWriteStruct in_mem = new InputWriteStruct();    </p>
</li>
<li><p>OutputStruct out_mem = new OutputStruct();    </p>
</li>
<li><p>if (address == 0 || buf == 0)    </p>
</li>
<li><p>returnfalse;    </p>
</li>
<li><p>ulong io = 0;    </p>
</li>
<li><p>if (len == 4)    </p>
</li>
<li><p>{    </p>
</li>
<li><p>in_mem.AddressHigh = (uint)HIDWORD(address);    </p>
</li>
<li><p>in_mem.AddressLow = (uint)LODWORD(address);    </p>
</li>
<li><p>in_mem.Value = <em>(uint</em>)buf;    </p>
</li>
<li><p>return Nt.DeviceIoControl(g_DeviceHandle, IOCTL_WritePhysicalAddress, &amp;in_mem, (uint)Marshal.SizeOf(typeof(InputWriteStruct)), &amp;out_mem, (uint)Marshal.SizeOf(typeof(OutputStruct)), &amp;io, 0);    </p>
</li>
<li><p>}    </p>
</li>
<li><p>else</p>
</li>
<li><p>{    </p>
</li>
<li><p>for (uint i = 0; i &lt; len / 4; i++)    </p>
</li>
<li><p>{    </p>
</li>
<li><p>in_mem.AddressHigh = (uint)HIDWORD(address + 4 * i);    </p>
</li>
<li><p>in_mem.AddressLow = (uint)LODWORD(address + 4 * i);    </p>
</li>
<li><p>in_mem.Value = ((uint*)buf)[i];    </p>
</li>
<li><p>if (!Nt.DeviceIoControl(g_DeviceHandle, IOCTL_WritePhysicalAddress, &amp;in_mem, (uint)Marshal.SizeOf(typeof(InputWriteStruct)), &amp;out_mem, (uint)Marshal.SizeOf(typeof(OutputStruct)), &amp;io, 0))    </p>
</li>
<li><p>returnfalse;    </p>
</li>
<li><p>}    </p>
</li>
<li><p>returntrue;    </p>
</li>
<li><p>}    </p>
</li>
<li><p>}    </p>
</li>
<li><p>/// <summary>  </summary></p>
</li>
<li><p>/// Read buffer, of specified length, at system address  </p>
</li>
<li><p>///   </p>
</li>
<li><p>/// <returns>Success</returns>  </p>
</li>
<li><p>publicbool ReadSystemAddress(ulong address, ulong buf, ulong len)    </p>
</li>
<li><p>{    </p>
</li>
<li><p>ulong dirbase = ReadControlRegister(3); // FOR ADDRESS TRANSLATION  </p>
</li>
<li><p>ulong phys = TranslateLinearAddress(dirbase, address);    </p>
</li>
<li><p>if (phys == 0)    </p>
</li>
<li><p>returnfalse;    </p>
</li>
<li><p>return ReadPhysicalAddress(phys, buf, len);    </p>
</li>
<li><p>}    </p>
</li>
<li><p>/// <summary>  </summary></p>
</li>
<li><p>/// Write buffer, of specified length, at system address  </p>
</li>
<li><p>///   </p>
</li>
<li><p>/// <returns>Success</returns>  </p>
</li>
<li><p>publicbool WriteSystemAddress(ulong address, ulong buf, ulong len)    </p>
</li>
<li><p>{    </p>
</li>
<li><p>ulong dirbase = ReadControlRegister(3); // FOR ADDRESS TRANSLATION  </p>
</li>
<li><p>ulong phys = TranslateLinearAddress(dirbase, address);    </p>
</li>
<li><p>if (phys == 0)    </p>
</li>
<li><p>returnfalse;    </p>
</li>
<li><p>return WritePhysicalAddress(phys, buf, len);    </p>
</li>
<li><p>}    </p>
</li>
<li><p>// GENERIC WRAPPERS  </p>
</li>
<li><p>public T ReadPhysicalAddress<t>(ulong address) where T : struct</t></p>
</li>
<li><p>{    </p>
</li>
<li><p>var buf = (ulong*)Marshal.AllocHGlobal(Marshal.SizeOf(typeof(T)));    </p>
</li>
<li><p>if (!ReadPhysicalAddress(address, (ulong)buf, (ulong)Marshal.SizeOf(typeof(T))))    </p>
</li>
<li><p>thrownew Exception(“Read failed”);    </p>
</li>
<li><p>T result = (T)Marshal.PtrToStructure((IntPtr)buf, typeof(T));    </p>
</li>
<li><p>Marshal.FreeHGlobal((IntPtr)buf);    </p>
</li>
<li><p>return result;    </p>
</li>
<li><p>}    </p>
</li>
<li><p>public T ReadSystemAddress<t>(ulong address) where T : struct</t></p>
</li>
<li><p>{    </p>
</li>
<li><p>var buf = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(T)));    </p>
</li>
<li><p>if (!ReadSystemAddress(address, (ulong)buf, (ulong)Marshal.SizeOf(typeof(T))))    </p>
</li>
<li><p>thrownew Exception(“Read failed”);    </p>
</li>
<li><p>T result = (T)Marshal.PtrToStructure(buf, typeof(T));    </p>
</li>
<li><p>Marshal.FreeHGlobal(buf);    </p>
</li>
<li><p>return result;    </p>
</li>
<li><p>}    </p>
</li>
<li><p>publicbool WritePhysicalAddress<t>(ulong address, T value) where T : struct</t></p>
</li>
<li><p>{    </p>
</li>
<li><p>var buf = (ulong)Marshal.AllocHGlobal(Marshal.SizeOf(typeof(T)));    </p>
</li>
<li><p>Marshal.StructureToPtr(value, (IntPtr)buf, false);    </p>
</li>
<li><p>bool success = WritePhysicalAddress(address, buf, (ulong)Marshal.SizeOf(typeof(T)));    </p>
</li>
<li><p>Marshal.FreeHGlobal((IntPtr)buf);    </p>
</li>
<li><p>return success;    </p>
</li>
<li><p>}    </p>
</li>
<li><p>publicbool WriteSystemAddress<t>(ulong address, T value) where T : struct</t></p>
</li>
<li><p>{    </p>
</li>
<li><p>var buf = (ulong)Marshal.AllocHGlobal(Marshal.SizeOf(typeof(T)));    </p>
</li>
<li><p>Marshal.StructureToPtr(value, (IntPtr)buf, false);    </p>
</li>
<li><p>bool success = WriteSystemAddress(address, buf, (ulong)Marshal.SizeOf(typeof(T)));    </p>
</li>
<li><p>Marshal.FreeHGlobal((IntPtr)buf);    </p>
</li>
<li><p>return success;    </p>
</li>
<li><p>}    </p>
</li>
<li><p>/// <summary>  </summary></p>
</li>
<li><p>/// Native functions ?  </p>
</li>
<li><p>///   </p>
</li>
<li><p>privatestaticclass Nt    </p>
</li>
<li><p>{    </p>
</li>
<li><p>#region Function  </p>
</li>
<li><p>[DllImport(“kernel32.dll”, ExactSpelling = true, SetLastError = true, CharSet = CharSet.Auto)]    </p>
</li>
<li><p>publicstaticexternbool DeviceIoControl(    </p>
</li>
<li><p>IntPtr hDevice,    </p>
</li>
<li><p>uint dwIoControlCode,    </p>
</li>
<li><p>void* lpInBuffer,    </p>
</li>
<li><p>uint nInBufferSize,    </p>
</li>
<li><p>void* lpOutBuffer,    </p>
</li>
<li><p>uint nOutBufferSize,    </p>
</li>
<li><p>ulong* lpBytesReturned,    </p>
</li>
<li><p>uint lpOverlapped);    </p>
</li>
<li><p>[DllImport(“kernel32.dll”, SetLastError = true)]    </p>
</li>
<li><p>[return: MarshalAs(UnmanagedType.Bool)]    </p>
</li>
<li><p>publicstaticexternbool CloseHandle(IntPtr hObject);    </p>
</li>
<li><p>[DllImport(“ntdll.dll”, CharSet = CharSet.Auto)]    </p>
</li>
<li><p>publicstaticexternuint NtOpenFile(IntPtr* FileHandle, uint DesiredAccess, OBJECT_ATTRIBUTES* ObjectAttributes, IO_STATUS_BLOCK* IoStatusBlock, uint ShareAccess, uint OpenOptions);    </p>
</li>
<li><p>#endregion  </p>
</li>
<li><p>#region Structs  </p>
</li>
<li><p>[StructLayout(LayoutKind.Sequential, Pack = 0)]    </p>
</li>
<li><p>publicstruct OBJECT_ATTRIBUTES    </p>
</li>
<li><p>{    </p>
</li>
<li><p>public Int32 Length;    </p>
</li>
<li><p>public IntPtr RootDirectory;    </p>
</li>
<li><p>public IntPtr ObjectName;    </p>
</li>
<li><p>publicuint Attributes;    </p>
</li>
<li><p>public IntPtr SecurityDescriptor;    </p>
</li>
<li><p>public IntPtr SecurityQualityOfService;    </p>
</li>
<li><p>}    </p>
</li>
<li><p>[StructLayout(LayoutKind.Sequential, Pack = 0)]    </p>
</li>
<li><p>publicstruct IO_STATUS_BLOCK    </p>
</li>
<li><p>{    </p>
</li>
<li><p>publicuint status;    </p>
</li>
<li><p>public IntPtr information;    </p>
</li>
<li><p>}    </p>
</li>
<li><p>[StructLayout(LayoutKind.Sequential)]    </p>
</li>
<li><p>publicstruct UNICODE_STRING : IDisposable    </p>
</li>
<li><p>{    </p>
</li>
<li><p>publicushort Length;    </p>
</li>
<li><p>publicushort MaximumLength;    </p>
</li>
<li><p>private IntPtr buffer;    </p>
</li>
<li><p>public UNICODE_STRING(string s)    </p>
</li>
<li><p>{    </p>
</li>
<li><p>Length = (ushort)(s.Length * 2);    </p>
</li>
<li><p>MaximumLength = (ushort)(Length + 2);    </p>
</li>
<li><p>buffer = Marshal.StringToHGlobalUni(s);    </p>
</li>
<li><p>}    </p>
</li>
<li><p>publicvoid Dispose()    </p>
</li>
<li><p>{    </p>
</li>
<li><p>Marshal.FreeHGlobal(buffer);    </p>
</li>
<li><p>buffer = IntPtr.Zero;    </p>
</li>
<li><p>}    </p>
</li>
<li><p>publicoverridestring ToString()    </p>
</li>
<li><p>{    </p>
</li>
<li><p>return Marshal.PtrToStringUni(buffer);    </p>
</li>
<li><p>}    </p>
</li>
<li><p>}    </p>
</li>
<li><p>#endregion  </p>
</li>
<li><p>#region Flags  </p>
</li>
<li><p>[Flags]    </p>
</li>
<li><p>publicenum SERVICE_ACCESS : uint</p>
</li>
<li><p>{    </p>
</li>
<li><p>/// <summary>  </summary></p>
</li>
<li><p>/// Required to call the QueryServiceConfig and   </p>
</li>
<li><p>/// QueryServiceConfig2 functions to query the service configuration.  </p>
</li>
<li><p>///   </p>
</li>
<li><p>SERVICE_QUERY_CONFIG = 0x00001,    </p>
</li>
<li><p>/// <summary>  </summary></p>
</li>
<li><p>/// Required to call the ChangeServiceConfig or ChangeServiceConfig2 function   </p>
</li>
<li><p>/// to change the service configuration. Because this grants the caller   </p>
</li>
<li><p>/// the right to change the executable file that the system runs,   </p>
</li>
<li><p>/// it should be granted only to administrators.  </p>
</li>
<li><p>///   </p>
</li>
<li><p>SERVICE_CHANGE_CONFIG = 0x00002,    </p>
</li>
<li><p>/// <summary>  </summary></p>
</li>
<li><p>/// Required to call the QueryServiceStatusEx function to ask the service   </p>
</li>
<li><p>/// control manager about the status of the service.  </p>
</li>
<li><p>///   </p>
</li>
<li><p>SERVICE_QUERY_STATUS = 0x00004,    </p>
</li>
<li><p>/// <summary>  </summary></p>
</li>
<li><p>/// Required to call the EnumDependentServices function to enumerate all   </p>
</li>
<li><p>/// the services dependent on the service.  </p>
</li>
<li><p>///   </p>
</li>
<li><p>SERVICE_ENUMERATE_DEPENDENTS = 0x00008,    </p>
</li>
<li><p>/// <summary>  </summary></p>
</li>
<li><p>/// Required to call the StartService function to start the service.  </p>
</li>
<li><p>///   </p>
</li>
<li><p>SERVICE_START = 0x00010,    </p>
</li>
<li><p>/// <summary>  </summary></p>
</li>
<li><p>///     Required to call the ControlService function to stop the service.  </p>
</li>
<li><p>///   </p>
</li>
<li><p>SERVICE_STOP = 0x00020,    </p>
</li>
<li><p>/// <summary>  </summary></p>
</li>
<li><p>/// Required to call the ControlService function to pause or continue   </p>
</li>
<li><p>/// the service.  </p>
</li>
<li><p>///   </p>
</li>
<li><p>SERVICE_PAUSE_CONTINUE = 0x00040,    </p>
</li>
<li><p>/// <summary>  </summary></p>
</li>
<li><p>/// Required to call the EnumDependentServices function to enumerate all  </p>
</li>
<li><p>/// the services dependent on the service.  </p>
</li>
<li><p>///   </p>
</li>
<li><p>SERVICE_INTERROGATE = 0x00080,    </p>
</li>
<li><p>/// <summary>  </summary></p>
</li>
<li><p>/// Required to call the ControlService function to specify a user-defined  </p>
</li>
<li><p>/// control code.  </p>
</li>
<li><p>///   </p>
</li>
<li><p>SERVICE_USER_DEFINED_CONTROL = 0x00100,    </p>
</li>
<li><p>/// <summary>  </summary></p>
</li>
<li><p>/// Includes STANDARD_RIGHTS_REQUIRED in addition to all access rights in this table.  </p>
</li>
<li><p>///   </p>
</li>
<li><p>SERVICE_ALL_ACCESS = (ACCESS_MASK.STANDARD_RIGHTS_REQUIRED |    </p>
</li>
<li><p>SERVICE_QUERY_CONFIG |    </p>
</li>
<li><p>SERVICE_CHANGE_CONFIG |    </p>
</li>
<li><p>SERVICE_QUERY_STATUS |    </p>
</li>
<li><p>SERVICE_ENUMERATE_DEPENDENTS |    </p>
</li>
<li><p>SERVICE_START |    </p>
</li>
<li><p>SERVICE_STOP |    </p>
</li>
<li><p>SERVICE_PAUSE_CONTINUE |    </p>
</li>
<li><p>SERVICE_INTERROGATE |    </p>
</li>
<li><p>SERVICE_USER_DEFINED_CONTROL),    </p>
</li>
<li><p>GENERIC_READ = ACCESS_MASK.STANDARD_RIGHTS_READ |    </p>
</li>
<li><p>SERVICE_QUERY_CONFIG |    </p>
</li>
<li><p>SERVICE_QUERY_STATUS |    </p>
</li>
<li><p>SERVICE_INTERROGATE |    </p>
</li>
<li><p>SERVICE_ENUMERATE_DEPENDENTS,    </p>
</li>
<li><p>GENERIC_WRITE = ACCESS_MASK.STANDARD_RIGHTS_WRITE |    </p>
</li>
<li><p>SERVICE_CHANGE_CONFIG,    </p>
</li>
<li><p>GENERIC_EXECUTE = ACCESS_MASK.STANDARD_RIGHTS_EXECUTE |    </p>
</li>
<li><p>SERVICE_START |    </p>
</li>
<li><p>SERVICE_STOP |    </p>
</li>
<li><p>SERVICE_PAUSE_CONTINUE |    </p>
</li>
<li><p>SERVICE_USER_DEFINED_CONTROL,    </p>
</li>
<li><p>/// <summary>  </summary></p>
</li>
<li><p>/// Required to call the QueryServiceObjectSecurity or   </p>
</li>
<li><p>/// SetServiceObjectSecurity function to access the SACL. The proper  </p>
</li>
<li><p>/// way to obtain this access is to enable the SE_SECURITY_NAME   </p>
</li>
<li><p>/// privilege in the caller’s current access token, open the handle   </p>
</li>
<li><p>/// for ACCESS_SYSTEM_SECURITY access, and then disable the privilege.  </p>
</li>
<li><p>///   </p>
</li>
<li><p>ACCESS_SYSTEM_SECURITY = ACCESS_MASK.ACCESS_SYSTEM_SECURITY,    </p>
</li>
<li><p>/// <summary>  </summary></p>
</li>
<li><p>/// Required to call the DeleteService function to delete the service.  </p>
</li>
<li><p>///   </p>
</li>
<li><p>DELETE = ACCESS_MASK.DELETE,    </p>
</li>
<li><p>/// <summary>  </summary></p>
</li>
<li><p>/// Required to call the QueryServiceObjectSecurity function to query  </p>
</li>
<li><p>/// the security descriptor of the service object.  </p>
</li>
<li><p>///   </p>
</li>
<li><p>READ_CONTROL = ACCESS_MASK.READ_CONTROL,    </p>
</li>
<li><p>/// <summary>  </summary></p>
</li>
<li><p>/// Required to call the SetServiceObjectSecurity function to modify  </p>
</li>
<li><p>/// the Dacl member of the service object’s security descriptor.  </p>
</li>
<li><p>///   </p>
</li>
<li><p>WRITE_DAC = ACCESS_MASK.WRITE_DAC,    </p>
</li>
<li><p>/// <summary>  </summary></p>
</li>
<li><p>/// Required to call the SetServiceObjectSecurity function to modify   </p>
</li>
<li><p>/// the Owner and Group members of the service object’s security   </p>
</li>
<li><p>/// descriptor.  </p>
</li>
<li><p>///   </p>
</li>
<li><p>WRITE_OWNER = ACCESS_MASK.WRITE_OWNER,    </p>
</li>
<li><p>}    </p>
</li>
<li><p>[Flags]    </p>
</li>
<li><p>publicenum ACCESS_MASK : uint</p>
</li>
<li><p>{    </p>
</li>
<li><p>DELETE = 0x00010000,    </p>
</li>
<li><p>READ_CONTROL = 0x00020000,    </p>
</li>
<li><p>WRITE_DAC = 0x00040000,    </p>
</li>
<li><p>WRITE_OWNER = 0x00080000,    </p>
</li>
<li><p>SYNCHRONIZE = 0x00100000,    </p>
</li>
<li><p>STANDARD_RIGHTS_REQUIRED = 0x000F0000,    </p>
</li>
<li><p>STANDARD_RIGHTS_READ = 0x00020000,    </p>
</li>
<li><p>STANDARD_RIGHTS_WRITE = 0x00020000,    </p>
</li>
<li><p>STANDARD_RIGHTS_EXECUTE = 0x00020000,    </p>
</li>
<li><p>STANDARD_RIGHTS_ALL = 0x001F0000,    </p>
</li>
<li><p>SPECIFIC_RIGHTS_ALL = 0x0000FFFF,    </p>
</li>
<li><p>ACCESS_SYSTEM_SECURITY = 0x01000000,    </p>
</li>
<li><p>MAXIMUM_ALLOWED = 0x02000000,    </p>
</li>
<li><p>GENERIC_READ = 0x80000000,    </p>
</li>
<li><p>GENERIC_WRITE = 0x40000000,    </p>
</li>
<li><p>GENERIC_EXECUTE = 0x20000000,    </p>
</li>
<li><p>GENERIC_ALL = 0x10000000,    </p>
</li>
<li><p>DESKTOP_READOBJECTS = 0x00000001,    </p>
</li>
<li><p>DESKTOP_CREATEWINDOW = 0x00000002,    </p>
</li>
<li><p>DESKTOP_CREATEMENU = 0x00000004,    </p>
</li>
<li><p>DESKTOP_HOOKCONTROL = 0x00000008,    </p>
</li>
<li><p>DESKTOP_JOURNALRECORD = 0x00000010,    </p>
</li>
<li><p>DESKTOP_JOURNALPLAYBACK = 0x00000020,    </p>
</li>
<li><p>DESKTOP_ENUMERATE = 0x00000040,    </p>
</li>
<li><p>DESKTOP_WRITEOBJECTS = 0x00000080,    </p>
</li>
<li><p>DESKTOP_SWITCHDESKTOP = 0x00000100,    </p>
</li>
<li><p>WINSTA_ENUMDESKTOPS = 0x00000001,    </p>
</li>
<li><p>WINSTA_READATTRIBUTES = 0x00000002,    </p>
</li>
<li><p>WINSTA_ACCESSCLIPBOARD = 0x00000004,    </p>
</li>
<li><p>WINSTA_CREATEDESKTOP = 0x00000008,    </p>
</li>
<li><p>WINSTA_WRITEATTRIBUTES = 0x00000010,    </p>
</li>
<li><p>WINSTA_ACCESSGLOBALATOMS = 0x00000020,    </p>
</li>
<li><p>WINSTA_EXITWINDOWS = 0x00000040,    </p>
</li>
<li><p>WINSTA_ENUMERATE = 0x00000100,    </p>
</li>
<li><p>WINSTA_READSCREEN = 0x00000200,    </p>
</li>
<li><p>WINSTA_ALL_ACCESS = 0x0000037F    </p>
</li>
<li><p>}    </p>
</li>
<li><p>/// <summary>  </summary></p>
</li>
<li><p>/// Service start options  </p>
</li>
<li><p>///   </p>
</li>
<li><p>publicenum SERVICE_START : uint</p>
</li>
<li><p>{    </p>
</li>
<li><p>/// <summary>  </summary></p>
</li>
<li><p>/// A device driver started by the system loader. This value is valid  </p>
</li>
<li><p>/// only for driver services.  </p>
</li>
<li><p>///   </p>
</li>
<li><p>SERVICE_BOOT_START = 0x00000000,    </p>
</li>
<li><p>/// <summary>  </summary></p>
</li>
<li><p>/// A device driver started by the IoInitSystem function. This value   </p>
</li>
<li><p>/// is valid only for driver services.  </p>
</li>
<li><p>///   </p>
</li>
<li><p>SERVICE_SYSTEM_START = 0x00000001,    </p>
</li>
<li><p>/// <summary>  </summary></p>
</li>
<li><p>/// A service started automatically by the service control manager   </p>
</li>
<li><p>/// during system startup. For more information, see Automatically   </p>
</li>
<li><p>/// Starting Services.  </p>
</li>
<li><p>///            </p>
</li>
<li><p>SERVICE_AUTO_START = 0x00000002,    </p>
</li>
<li><p>/// <summary>  </summary></p>
</li>
<li><p>/// A service started by the service control manager when a process   </p>
</li>
<li><p>/// calls the StartService function. For more information, see   </p>
</li>
<li><p>/// Starting Services on Demand.  </p>
</li>
<li><p>///   </p>
</li>
<li><p>SERVICE_DEMAND_START = 0x00000003,    </p>
</li>
<li><p>/// <summary>  </summary></p>
</li>
<li><p>/// A service that cannot be started. Attempts to start the service  </p>
</li>
<li><p>/// result in the error code ERROR_SERVICE_DISABLED.  </p>
</li>
<li><p>///   </p>
</li>
<li><p>SERVICE_DISABLED = 0x00000004,    </p>
</li>
<li><p>}    </p>
</li>
<li><p>#endregion  </p>
</li>
<li><p>}    </p>
</li>
<li><p>}    </p>
</li>
<li><p>/// <summary>  </summary></p>
</li>
<li><p>/// Wrapper for the native service functions  </p>
</li>
<li><p>///   </p>
</li>
<li><p>publicstaticclass ServiceHelper    </p>
</li>
<li><p>{    </p>
</li>
<li><p>publicstaticbool CreateService(    </p>
</li>
<li><p>ref IntPtr hService,    </p>
</li>
<li><p>string ServiceName,    </p>
</li>
<li><p>string DisplayName,    </p>
</li>
<li><p>string BinPath,    </p>
</li>
<li><p>uint DesiredAccess,    </p>
</li>
<li><p>uint ServiceType,    </p>
</li>
<li><p>uint StartType,    </p>
</li>
<li><p>uint ErrorControl)    </p>
</li>
<li><p>{    </p>
</li>
<li><p>IntPtr hSCManager = Nt.OpenSCManager(0, 0, 0x0002/*SC_MANAGER_CREATE_SERVICE*/);    </p>
</li>
<li><p>if (hSCManager == IntPtr.Zero)    </p>
</li>
<li><p>returnfalse;    </p>
</li>
<li><p>hService = Nt.CreateServiceW(    </p>
</li>
<li><p>hSCManager,    </p>
</li>
<li><p>ServiceName, DisplayName,    </p>
</li>
<li><p>DesiredAccess,    </p>
</li>
<li><p>ServiceType, StartType,    </p>
</li>
<li><p>ErrorControl, BinPath,    </p>
</li>
<li><p>0, 0, 0, 0, 0, 0);    </p>
</li>
<li><p>Nt.CloseServiceHandle(hSCManager);    </p>
</li>
<li><p>return hService != IntPtr.Zero;    </p>
</li>
<li><p>}    </p>
</li>
<li><p>publicstaticbool OpenService(out IntPtr hService, string szServiceName, uint DesiredAccess)    </p>
</li>
<li><p>{    </p>
</li>
<li><p>IntPtr hSCManager = Nt.OpenSCManager(0, 0, DesiredAccess);    </p>
</li>
<li><p>hService = Nt.OpenService(hSCManager, szServiceName, DesiredAccess);    </p>
</li>
<li><p>Nt.CloseServiceHandle(hSCManager);    </p>
</li>
<li><p>return hService != IntPtr.Zero;    </p>
</li>
<li><p>}    </p>
</li>
<li><p>publicstaticbool StopService(IntPtr hService)    </p>
</li>
<li><p>{    </p>
</li>
<li><p>Nt.SERVICE_STATUS ServiceStatus = new Nt.SERVICE_STATUS();    </p>
</li>
<li><p>return Nt.ControlService(hService, Nt.SERVICE_CONTROL.STOP, ref ServiceStatus);    </p>
</li>
<li><p>}    </p>
</li>
<li><p>publicstaticbool StartService(IntPtr hService) =&gt; Nt.StartService(hService, 0, null);    </p>
</li>
<li><p>publicstaticbool DeleteService(IntPtr hService) =&gt; Nt.DeleteService(hService);    </p>
</li>
<li><p>publicstaticvoid CloseServiceHandle(IntPtr hService) =&gt; Nt.CloseServiceHandle(hService);    </p>
</li>
<li><p>/// <summary>  </summary></p>
</li>
<li><p>/// Native functions ?  </p>
</li>
<li><p>///   </p>
</li>
<li><p>privatestaticclass Nt    </p>
</li>
<li><p>{    </p>
</li>
<li><p>[DllImport(“advapi32.dll”, EntryPoint = “OpenSCManagerW”, ExactSpelling = true, CharSet = CharSet.Unicode, SetLastError = true)]    </p>
</li>
<li><p>publicstaticextern IntPtr OpenSCManager(uint machineName, uint databaseName, uint dwAccess);    </p>
</li>
<li><p>[DllImport(“advapi32.dll”, SetLastError = true, CharSet = CharSet.Auto)]    </p>
</li>
<li><p>publicstaticextern IntPtr OpenService(IntPtr hSCManager, string lpServiceName, uint dwDesiredAccess);    </p>
</li>
<li><p>[DllImport(“advapi32.dll”, SetLastError = true)]    </p>
</li>
<li><p>[return: MarshalAs(UnmanagedType.Bool)]    </p>
</li>
<li><p>publicstaticexternbool CloseServiceHandle(IntPtr hSCObject);    </p>
</li>
<li><p>[DllImport(“advapi32.dll”, SetLastError = true)]    </p>
</li>
<li><p>[return: MarshalAs(UnmanagedType.Bool)]    </p>
</li>
<li><p>publicstaticexternbool ControlService(IntPtr hService, SERVICE_CONTROL dwControl, ref SERVICE_STATUS lpServiceStatus);    </p>
</li>
<li><p>[DllImport(“advapi32”, SetLastError = true)]    </p>
</li>
<li><p>[return: MarshalAs(UnmanagedType.Bool)]    </p>
</li>
<li><p>publicstaticexternbool StartService(    </p>
</li>
<li><p>IntPtr hService,    </p>
</li>
<li><p>int dwNumServiceArgs,    </p>
</li>
<li><p>string[] lpServiceArgVectors    </p>
</li>
<li><p>);    </p>
</li>
<li><p>[DllImport(“advapi32.dll”, SetLastError = true)]    </p>
</li>
<li><p>[return: MarshalAs(UnmanagedType.Bool)]    </p>
</li>
<li><p>publicstaticexternbool DeleteService(IntPtr hService);    </p>
</li>
<li><p>[DllImport(“advapi32.dll”, SetLastError = true, CharSet = CharSet.Auto)]    </p>
</li>
<li><p>publicstaticextern IntPtr CreateServiceW(    </p>
</li>
<li><p>IntPtr hSCManager,    </p>
</li>
<li><p>string lpServiceName,    </p>
</li>
<li><p>string lpDisplayName,    </p>
</li>
<li><p>uint dwDesiredAccess,    </p>
</li>
<li><p>uint dwServiceType,    </p>
</li>
<li><p>uint dwStartType,    </p>
</li>
<li><p>uint dwErrorControl,    </p>
</li>
<li><p>string lpBinaryPathName,    </p>
</li>
<li><p>uint lpLoadOrderGroup,    </p>
</li>
<li><p>uint lpdwTagId,    </p>
</li>
<li><p>uint lpdwTagId1,    </p>
</li>
<li><p>uint lpDependencies,    </p>
</li>
<li><p>uint lpServiceStartName,    </p>
</li>
<li><p>uint lpPassword);    </p>
</li>
<li><p>[StructLayout(LayoutKind.Sequential, Pack = 0)]    </p>
</li>
<li><p>publicstruct SERVICE_STATUS    </p>
</li>
<li><p>{    </p>
</li>
<li><p>public SERVICE_TYPE dwServiceType;    </p>
</li>
<li><p>public SERVICE_STATE dwCurrentState;    </p>
</li>
<li><p>publicuint dwControlsAccepted;    </p>
</li>
<li><p>publicuint dwWin32ExitCode;    </p>
</li>
<li><p>publicuint dwServiceSpecificExitCode;    </p>
</li>
<li><p>publicuint dwCheckPoint;    </p>
</li>
<li><p>publicuint dwWaitHint;    </p>
</li>
<li><p>}    </p>
</li>
<li><p>[Flags]    </p>
</li>
<li><p>internalenum SERVICE_TYPE : int</p>
</li>
<li><p>{    </p>
</li>
<li><p>SERVICE_KERNEL_DRIVER = 0x00000001,    </p>
</li>
<li><p>SERVICE_FILE_SYSTEM_DRIVER = 0x00000002,    </p>
</li>
<li><p>SERVICE_WIN32_OWN_PROCESS = 0x00000010,    </p>
</li>
<li><p>SERVICE_WIN32_SHARE_PROCESS = 0x00000020,    </p>
</li>
<li><p>SERVICE_INTERACTIVE_PROCESS = 0x00000100    </p>
</li>
<li><p>}    </p>
</li>
<li><p>[Flags]    </p>
</li>
<li><p>publicenum SERVICE_CONTROL : uint</p>
</li>
<li><p>{    </p>
</li>
<li><p>STOP = 0x00000001,    </p>
</li>
<li><p>PAUSE = 0x00000002,    </p>
</li>
<li><p>CONTINUE = 0x00000003,    </p>
</li>
<li><p>INTERROGATE = 0x00000004,    </p>
</li>
<li><p>SHUTDOWN = 0x00000005,    </p>
</li>
<li><p>PARAMCHANGE = 0x00000006,    </p>
</li>
<li><p>NETBINDADD = 0x00000007,    </p>
</li>
<li><p>NETBINDREMOVE = 0x00000008,    </p>
</li>
<li><p>NETBINDENABLE = 0x00000009,    </p>
</li>
<li><p>NETBINDDISABLE = 0x0000000A,    </p>
</li>
<li><p>DEVICEEVENT = 0x0000000B,    </p>
</li>
<li><p>HARDWAREPROFILECHANGE = 0x0000000C,    </p>
</li>
<li><p>POWEREVENT = 0x0000000D,    </p>
</li>
<li><p>SESSIONCHANGE = 0x0000000E    </p>
</li>
<li><p>}    </p>
</li>
<li><p>publicenum SERVICE_STATE : uint</p>
</li>
<li><p>{    </p>
</li>
<li><p>SERVICE_STOPPED = 0x00000001,    </p>
</li>
<li><p>SERVICE_START_PENDING = 0x00000002,    </p>
</li>
<li><p>SERVICE_STOP_PENDING = 0x00000003,    </p>
</li>
<li><p>SERVICE_RUNNING = 0x00000004,    </p>
</li>
<li><p>SERVICE_CONTINUE_PENDING = 0x00000005,    </p>
</li>
<li><p>SERVICE_PAUSE_PENDING = 0x00000006,    </p>
</li>
<li><p>SERVICE_PAUSED = 0x00000007    </p>
</li>
<li><p>}    </p>
</li>
<li><p>[Flags]    </p>
</li>
<li><p>publicenum SERVICE_ACCEPT : uint</p>
</li>
<li><p>{    </p>
</li>
<li><p>STOP = 0x00000001,    </p>
</li>
<li><p>PAUSE_CONTINUE = 0x00000002,    </p>
</li>
<li><p>SHUTDOWN = 0x00000004,    </p>
</li>
<li><p>PARAMCHANGE = 0x00000008,    </p>
</li>
<li><p>NETBINDCHANGE = 0x00000010,    </p>
</li>
<li><p>HARDWAREPROFILECHANGE = 0x00000020,    </p>
</li>
<li><p>POWEREVENT = 0x00000040,    </p>
</li>
<li><p>SESSIONCHANGE = 0x00000080,    </p>
</li>
<li><p>}    </p>
</li>
<li><p>}    </p>
</li>
<li><p>}    </p>
</li>
<li><p>}    </p>
</li>
</ol>
<p>ElevateHandle:</p>
<ol>
<li><p>using Loadlibrayy.Logger;    </p>
</li>
<li><p>using Loadlibrayy.Natives;    </p>
</li>
<li><p>using System;    </p>
</li>
<li><p>using System.Collections;    </p>
</li>
<li><p>using System.Collections.Generic;    </p>
</li>
<li><p>using System.Diagnostics;    </p>
</li>
<li><p>using System.Linq;    </p>
</li>
<li><p>using System.Runtime.InteropServices;    </p>
</li>
<li><p>using System.Text;    </p>
</li>
<li><p>using System.Threading.Tasks;    </p>
</li>
<li><p>namespace DriverExploits    </p>
</li>
<li><p>{    </p>
</li>
<li><p>publicunsafestaticclass ElevateHandle    </p>
</li>
<li><p>{    </p>
</li>
<li><p>publicstatic CPUZ Driver = new CPUZ();    </p>
</li>
<li><p>#region Private Properties  </p>
</li>
<li><p>privatestatic NT.ProcessContext g_Context { get; set; }    </p>
</li>
<li><p>privatestaticulong g_VersionLong { get; set; }    </p>
</li>
<li><p>privatestaticuint g_OffsetDirectoryTable { get; set; }    </p>
</li>
<li><p>privatestaticuint g_OffsetProcessId { get; set; }    </p>
</li>
<li><p>privatestaticuint g_OffsetProcessLinks { get; set; }    </p>
</li>
<li><p>privatestaticuint g_OffsetObjectTable { get; set; }    </p>
</li>
<li><p>privatestaticbool g_IsWindows7Machine { get; set; }    </p>
</li>
<li><p>#endregion  </p>
</li>
<li><p>publicstaticvoid Attach() =&gt; g_Context = FindProcessInfo((uint)Process.GetCurrentProcess().Id);    </p>
</li>
<li><p>publicstaticbool Elevate(ulong handle, dynamic desiredAccess)    </p>
</li>
<li><p>{    </p>
</li>
<li><p>var handleTableAddress = ReadSystemMemory<ulong>(g_Context.KernelEntry + g_OffsetObjectTable);    </ulong></p>
</li>
<li><p>var handleTable = ReadSystemMemory&lt;_HANDLE_TABLE&gt;(handleTableAddress);    </p>
</li>
<li><p>NT._HANDLE_TABLE_ENTRY* entryAddress = g_IsWindows7Machine ?     </p>
</li>
<li><p>ExpLookupHandleTableEntryWin7(&amp;handleTable, handle) :     </p>
</li>
<li><p>ExpLookupHandleTableEntry(&amp;handleTable, handle);    </p>
</li>
<li><p>if ((ulong)entryAddress == 0)    </p>
</li>
<li><p>thrownew Exception(“ExpLookupHandleTableEntry/7 failed”);    </p>
</li>
<li><p>var entry = ReadSystemMemory&lt;NT._HANDLE_TABLE_ENTRY&gt;((ulong)entryAddress);    </p>
</li>
<li><p>bool didElevate = WriteSystemMemory((ulong)entryAddress + sizeof(ulong), (ulong)desiredAccess);    </p>
</li>
<li><p>Log.LogInfo($“Elevating {handle.ToString(“x2“)} -&gt; {desiredAccess.ToString(“x2“)} ? {didElevate}”);    </p>
</li>
<li><p>return didElevate;    </p>
</li>
<li><p>}    </p>
</li>
<li><p>publicstaticvoid UpdateDynamicData()    </p>
</li>
<li><p>{    </p>
</li>
<li><p>NT._OSVERSIONINFOEXW osvi = new NT._OSVERSIONINFOEXW()    </p>
</li>
<li><p>{    </p>
</li>
<li><p>dwOSVersionInfoSize = (uint)Marshal.SizeOf(typeof(NT._OSVERSIONINFOEXW))    </p>
</li>
<li><p>};    </p>
</li>
<li><p>NT.RtlGetVersion(&amp;osvi);    </p>
</li>
<li><p>g_VersionLong = (osvi.dwMajorVersion &lt;&lt; 16) | (osvi.dwMinorVersion &lt;&lt; 8) | osvi.wServicePackMajor;    </p>
</li>
<li><p>switch (g_VersionLong)    </p>
</li>
<li><p>{    </p>
</li>
<li><p>case 0x060101/*win 7*/:    </p>
</li>
<li><p>g_IsWindows7Machine = true;    </p>
</li>
<li><p>g_OffsetDirectoryTable = 0x028;    </p>
</li>
<li><p>g_OffsetProcessId = 0x180;    </p>
</li>
<li><p>g_OffsetProcessLinks = 0x188;    </p>
</li>
<li><p>g_OffsetObjectTable = 0x200;    </p>
</li>
<li><p>break;    </p>
</li>
<li><p>case 0x060200/*win 8*/:    </p>
</li>
<li><p>case 0x060300/*win 8.1*/:    </p>
</li>
<li><p>g_OffsetDirectoryTable = 0x028;    </p>
</li>
<li><p>g_OffsetProcessId = 0x2e0;    </p>
</li>
<li><p>g_OffsetProcessLinks = 0x2e8;    </p>
</li>
<li><p>g_OffsetObjectTable = 0x408;    </p>
</li>
<li><p>break;    </p>
</li>
<li><p>case 0x0A0000 /*win 10*/:    </p>
</li>
<li><p>{    </p>
</li>
<li><p>switch (osvi.dwBuildNumber)    </p>
</li>
<li><p>{    </p>
</li>
<li><p>case 10240:    </p>
</li>
<li><p>case 10586:    </p>
</li>
<li><p>case 14393:    </p>
</li>
<li><p>g_OffsetDirectoryTable = 0x028;    </p>
</li>
<li><p>g_OffsetProcessId = 0x2E8;    </p>
</li>
<li><p>g_OffsetProcessLinks = 0x2F0;    </p>
</li>
<li><p>g_OffsetObjectTable = 0x418;    </p>
</li>
<li><p>break;    </p>
</li>
<li><p>case 15063:    </p>
</li>
<li><p>g_OffsetDirectoryTable = 0x028;    </p>
</li>
<li><p>g_OffsetProcessId = 0x2E0;    </p>
</li>
<li><p>g_OffsetProcessLinks = 0x2E8;    </p>
</li>
<li><p>g_OffsetObjectTable = 0x418;    </p>
</li>
<li><p>break;    </p>
</li>
<li><p>default:    </p>
</li>
<li><p>thrownew Exception(“Unsupported dwBuildNumber”);    </p>
</li>
<li><p>}    </p>
</li>
<li><p>break;    </p>
</li>
<li><p>}    </p>
</li>
<li><p>default:    </p>
</li>
<li><p>thrownew Exception(“Unsupported version_long”);    </p>
</li>
<li><p>}    </p>
</li>
<li><p>}    </p>
</li>
<li><p>// IDA F5 LOL  </p>
</li>
<li><p>privatestatic NT._HANDLE_TABLE_ENTRY* ExpLookupHandleTableEntryWin7(void* HandleTable, ulong Handle)    </p>
</li>
<li><p>{    </p>
</li>
<li><p>ulong v2;     // r8@2  </p>
</li>
<li><p>ulong v3;     // rcx@2  </p>
</li>
<li><p>ulong v4;     // r8@2  </p>
</li>
<li><p>ulong result; // rax@4  </p>
</li>
<li><p>ulong v6;     // [sp+8h] [bp+8h]@1  </p>
</li>
<li><p>ulong table = (ulong)HandleTable;    </p>
</li>
<li><p>v6 = Handle;    </p>
</li>
<li><p>v6 = Handle &amp; 0xFFFFFFFC;    </p>
</li>
<li><p>if (v6 &gt;= <em>(uint</em>)(table + 92))    </p>
</li>
<li><p>{    </p>
</li>
<li><p>result = 0;    </p>
</li>
<li><p>}    </p>
</li>
<li><p>else</p>
</li>
<li><p>{    </p>
</li>
<li><p>v2 = (<em>(ulong</em>)table);    </p>
</li>
<li><p>v3 = (<em>(ulong</em>)table) &amp; 3;    </p>
</li>
<li><p>v4 = v2 – (uint)v3;    </p>
</li>
<li><p>if ((uint)v3 &gt; 0)    </p>
</li>
<li><p>{    </p>
</li>
<li><p>if ((uint)v3 == 1)    </p>
</li>
<li><p>result = ReadSystemMemory<ulong>((((Handle – (Handle &amp; 0x3FF)) &gt;&gt; 7) + v4)) + 4 * (Handle &amp; 0x3FF);    </ulong></p>
</li>
<li><p>else</p>
</li>
<li><p>result = ReadSystemMemory<ulong>((ulong)(ReadSystemMemory<ulong>((ulong)(((((Handle – (Handle &amp; 0x3FF)) &gt;&gt; 7) – (((Handle – (Handle &amp; 0x3FF)) &gt;&gt; 7) &amp; 0xFFF)) &gt;&gt; 9) + v4)) + (((Handle – (Handle &amp; 0x3FF)) &gt;&gt; 7) &amp; 0xFFF))) + 4 * (Handle &amp; 0x3FF);    </ulong></ulong></p>
</li>
<li><p>}    </p>
</li>
<li><p>else</p>
</li>
<li><p>{    </p>
</li>
<li><p>result = v4 + 4 * Handle;    </p>
</li>
<li><p>}    </p>
</li>
<li><p>}    </p>
</li>
<li><p>return (NT._HANDLE_TABLE_ENTRY*)result;    </p>
</li>
<li><p>}    </p>
</li>
<li><p>privatestatic NT._HANDLE_TABLE_ENTRY* ExpLookupHandleTableEntry(void* HandleTable, ulong Handle)    </p>
</li>
<li><p>{    </p>
</li>
<li><p>ulong v2; // rdx@1  </p>
</li>
<li><p>long v3; // r8@2  </p>
</li>
<li><p>ulong result; // rax@4  </p>
</li>
<li><p>ulong v5;    </p>
</li>
<li><p>ulong a1 = (ulong)HandleTable;    </p>
</li>
<li><p>v2 = Handle &amp; 0xFFFFFFFFFFFFFFFCu;    </p>
</li>
<li><p>if (v2 &gt;= <em>(uint</em>)a1)    </p>
</li>
<li><p>{    </p>
</li>
<li><p>result = 0;    </p>
</li>
<li><p>}    </p>
</li>
<li><p>else</p>
</li>
<li><p>{    </p>
</li>
<li><p>v3 = (long)<em>(ulong</em>)(a1 + 8);    </p>
</li>
<li><p>if ((<em>(ulong</em>)(a1 + 8) &amp; 3) &gt; 0)    </p>
</li>
<li><p>{    </p>
</li>
<li><p>if ((<em>(uint</em>)(a1 + 8) &amp; 3) == 1)    </p>
</li>
<li><p>{    </p>
</li>
<li><p>v5 = ReadSystemMemory<ulong>((ulong)v3 + 8 * (v2 &gt;&gt; 10) – 1);    </ulong></p>
</li>
<li><p>result = v5 + 4 * (v2 &amp; 0x3FF);    </p>
</li>
<li><p>}    </p>
</li>
<li><p>else</p>
</li>
<li><p>{    </p>
</li>
<li><p>v5 = ReadSystemMemory<ulong>(ReadSystemMemory<ulong>((ulong)v3 + 8 * (v2 &gt;&gt; 19) – 2) + 8 * ((v2 &gt;&gt; 10) &amp; 0x1FF));    </ulong></ulong></p>
</li>
<li><p>result = v5 + 4 * (v2 &amp; 0x3FF);    </p>
</li>
<li><p>}    </p>
</li>
<li><p>}    </p>
</li>
<li><p>else</p>
</li>
<li><p>{    </p>
</li>
<li><p>result = (ulong)v3 + 4 * v2;    </p>
</li>
<li><p>}    </p>
</li>
<li><p>}    </p>
</li>
<li><p>return (NT._HANDLE_TABLE_ENTRY*)result;    </p>
</li>
<li><p>}    </p>
</li>
<li><p>// MEMORY FUNCTIONS  </p>
</li>
<li><p>privatestatic T ReadSystemMemory<t>(ulong basepointer)    </t></p>
</li>
<li><p>{    </p>
</li>
<li><p>var buf = (ulong*)Marshal.AllocHGlobal(Marshal.SizeOf(typeof(T)));    </p>
</li>
<li><p>if (!ReadSystemMemory(basepointer, (ulong)buf, (uint)Marshal.SizeOf(typeof(T))))    </p>
</li>
<li><p>thrownew Exception(“Read failed”);    </p>
</li>
<li><p>T result = (T)Marshal.PtrToStructure((IntPtr)buf, typeof(T));    </p>
</li>
<li><p>Marshal.FreeHGlobal((IntPtr)buf);    </p>
</li>
<li><p>return result;    </p>
</li>
<li><p>}    </p>
</li>
<li><p>privatestaticbool WriteSystemMemory<t>(ulong basepointer, T value)    </t></p>
</li>
<li><p>{    </p>
</li>
<li><p>var buf = (ulong)Marshal.AllocHGlobal(Marshal.SizeOf(typeof(T)));    </p>
</li>
<li><p>Marshal.StructureToPtr(value, (IntPtr)buf, false);    </p>
</li>
<li><p>bool success = WriteSystemMemory(basepointer, buf, (uint)Marshal.SizeOf(typeof(T)));    </p>
</li>
<li><p>Marshal.FreeHGlobal((IntPtr)buf);    </p>
</li>
<li><p>return success;    </p>
</li>
<li><p>}    </p>
</li>
<li><p>privatestaticbool ReadSystemMemory(ulong basepointer, ulong buf, uint len)    </p>
</li>
<li><p>{    </p>
</li>
<li><p>ulong phys = Driver.TranslateLinearAddress(g_Context.DirectoryBase, basepointer);    </p>
</li>
<li><p>return Driver.ReadPhysicalAddress(phys, buf, len);    </p>
</li>
<li><p>}    </p>
</li>
<li><p>privatestaticbool WriteSystemMemory(ulong basepointer, ulong buf, uint len)    </p>
</li>
<li><p>{    </p>
</li>
<li><p>ulong phys = Driver.TranslateLinearAddress(g_Context.DirectoryBase, basepointer);    </p>
</li>
<li><p>return Driver.WritePhysicalAddress(phys, buf, len);    </p>
</li>
<li><p>}    </p>
</li>
<li><p>privatestaticulong GetKernelBase()    </p>
</li>
<li><p>{    </p>
</li>
<li><p>ulong buffer;    </p>
</li>
<li><p>uint bufferSize = 2048;    </p>
</li>
<li><p>buffer = (ulong)Marshal.AllocHGlobal((int)bufferSize);    </p>
</li>
<li><p>uint status = NT.NtQuerySystemInformation(11/*SystemModuleInformation*/, buffer, (uint)bufferSize, out bufferSize);    </p>
</li>
<li><p>if (status == 0xC0000004L/*STATUS_INFO_LENGTH_MISMATCH*/)    </p>
</li>
<li><p>{    </p>
</li>
<li><p>Marshal.FreeHGlobal((IntPtr)buffer);    </p>
</li>
<li><p>buffer = (ulong)Marshal.AllocHGlobal((int)bufferSize);    </p>
</li>
<li><p>status = NT.NtQuerySystemInformation(11/*SystemModuleInformation*/, buffer, (uint)bufferSize, out bufferSize);    </p>
</li>
<li><p>}    </p>
</li>
<li><p>if (status != 0)    </p>
</li>
<li><p>thrownew Exception(“GetKernelBase Failed”);    </p>
</li>
<li><p>NT._RTL_PROCESS_MODULES* modulesPointer = (NT._RTL_PROCESS_MODULES*)buffer;    </p>
</li>
<li><p>return (ulong)modulesPointer-&gt;Modules.ImageBase;    </p>
</li>
<li><p>}    </p>
</li>
<li><p>privatestaticbyte* FindKernelProcedure(string szName)    </p>
</li>
<li><p>{    </p>
</li>
<li><p>ulong ntoskrnlHandle = NT.LoadLibrary(“ntoskrnl.exe”);    </p>
</li>
<li><p>ulong kernelBase = GetKernelBase();    </p>
</li>
<li><p>ulong functionPointer = NT.GetProcAddress(ntoskrnlHandle, szName);    </p>
</li>
<li><p>return (byte*)(functionPointer – ntoskrnlHandle + kernelBase);    </p>
</li>
<li><p>}    </p>
</li>
<li><p>privatestatic NT.ProcessContext FindProcessInfo(uint targetProcessId)    </p>
</li>
<li><p>{    </p>
</li>
<li><p>NT.ProcessContext processContext = new NT.ProcessContext()    </p>
</li>
<li><p>{    </p>
</li>
<li><p>ProcessId = 0    </p>
</li>
<li><p>};    </p>
</li>
<li><p>// GET POINTER TO THE SYSTEM EPROCESS  </p>
</li>
<li><p>ulong eprocessPointer = (ulong)FindKernelProcedure(“PsInitialSystemProcess”);    </p>
</li>
<li><p>// READ EPROCESS ADDRESS  </p>
</li>
<li><p>ulong ntosEntry = Driver.ReadSystemAddress<ulong>(eprocessPointer);    </ulong></p>
</li>
<li><p>var listHead = ntosEntry + g_OffsetProcessLinks;    </p>
</li>
<li><p>var lastLink = Driver.ReadSystemAddress<ulong>(listHead + sizeof(ulong));    </ulong></p>
</li>
<li><p>// ITERATE ALL PROCESSES  </p>
</li>
<li><p>for (var currentLink = listHead; currentLink != lastLink; currentLink = Driver.ReadSystemAddress<ulong>(currentLink))    </ulong></p>
</li>
<li><p>{    </p>
</li>
<li><p>var currentEntry = currentLink – g_OffsetProcessLinks;    </p>
</li>
<li><p>var processId = Driver.ReadSystemAddress<ulong>(currentEntry + g_OffsetProcessId);    </ulong></p>
</li>
<li><p>// PID is a match  </p>
</li>
<li><p>if (processId == targetProcessId)    </p>
</li>
<li><p>{    </p>
</li>
<li><p>processContext.ProcessId = targetProcessId;    </p>
</li>
<li><p>processContext.DirectoryBase = Driver.ReadSystemAddress<ulong>(currentEntry + g_OffsetDirectoryTable);    </ulong></p>
</li>
<li><p>processContext.KernelEntry = currentEntry;    </p>
</li>
<li><p>break;    </p>
</li>
<li><p>}    </p>
</li>
<li><p>}    </p>
</li>
<li><p>return processContext;    </p>
</li>
<li><p>}    </p>
</li>
<li><p>[StructLayout(LayoutKind.Sequential)]    </p>
</li>
<li><p>publicstruct _HANDLE_TABLE    </p>
</li>
<li><p>{    </p>
</li>
<li><p>publiculong TableCode;    </p>
</li>
<li><p>publiculong QuotaProcess;    </p>
</li>
<li><p>publiculong UniqueProcessId;    </p>
</li>
<li><p>publiculong HandleLock;    </p>
</li>
<li><p>publiculong Flink;    </p>
</li>
<li><p>publiculong Blink;    </p>
</li>
<li><p>publiculong HandleContentionEvent;    </p>
</li>
<li><p>publiculong DebugInfo;    </p>
</li>
<li><p>publicint ExtraInfoPages;    </p>
</li>
<li><p>publicuint Flags;    </p>
</li>
<li><p>publicuint FirstFreeHandle;    </p>
</li>
<li><p>publiculong LastFreeHandleEntry;    </p>
</li>
<li><p>publicuint HandleCount;    </p>
</li>
<li><p>publicuint NextHandleNeedingPool;    </p>
</li>
<li><p>publicuint HandleCountHighWatermark;    </p>
</li>
<li><p>}    </p>
</li>
<li><p>}    </p>
</li>
<li><p>}</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://iuu.me/battleye-bypass/" data-id="cjvp22zzy002xsomhzg189kty" class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/battleye/">battleye</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/bypass/">bypass</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpu-z/">cpu-z</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/csharp/">csharp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dirver/">dirver</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
        <article id="post-analysisjson" class="article article-type-post" itemscope="" itemprop="blogPost" data-scroll-reveal="">

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/analysisjson/">Newtonsoft.Json简单解析多嵌套Json的某个属性</a>
    </h2>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/analysisjson/" class="article-date">
  <time datetime="2017-06-17T08:31:43.000Z" itemprop="datePublished">2017-06-17</time>
</a>
        
  <div class="article-category">
    <a class="article-category-link" href="/categories/Code/">Code</a>
  </div>

      </div>
    

    <div class="article-entry" itemprop="articleBody">
      

      

      
        <p><img src="https://iuu.me/wp-content/uploads/2018/07/timg-1-1-300x143.jpg" alt=""> Json轻量又可读性高，但是有的场景下面Json多嵌套的模式下解析起来确实很烦，特别是只需要某一个数据的情况下。 不过Newtonsoft.Json给我们提供了一个轻便又简单的方法： 方法原型：</p>
<ol>
<li>public JToken SelectToken(string path)  </li>
</ol>
<p>比如只想要data.commentContentArr.users.info.profile下面的某个userImg属性：</p>
<ol>
<li>jsonData.SelectToken($”data.commentContentArr.users.info.profile{((JProperty)item).Name}.userImg”)  </li>
</ol>
<p>如果层级关系写错会抛异常出来而不是返回一个null给你…</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://iuu.me/analysisjson/" data-id="cjvp22zyl0003somhclxsmaux" class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Newtonsoft/">Newtonsoft</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/json/">json</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
        <article id="post-win32apiinstallwindowsservice" class="article article-type-post" itemscope="" itemprop="blogPost" data-scroll-reveal="">

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/win32apiinstallwindowsservice/">Win32API安装windows服务</a>
    </h2>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/win32apiinstallwindowsservice/" class="article-date">
  <time datetime="2017-06-08T10:12:12.000Z" itemprop="datePublished">2017-06-08</time>
</a>
        
  <div class="article-category">
    <a class="article-category-link" href="/categories/Code/">Code</a>
  </div>

      </div>
    

    <div class="article-entry" itemprop="articleBody">
      

      

      
        <p><img src="https://iuu.me/wp-content/uploads/2018/07/QQ%E6%88%AA%E5%9B%BE20180723182825-300x200.jpg" alt=""> 通过调用win32API来执行windows服务的安装/配置/卸载管理。 这算是变相的拒绝bat吗… 采用传统Form实现。 Form1:</p>
<ol>
<li><p>using System;  </p>
</li>
<li><p>using System.Collections.Generic;  </p>
</li>
<li><p>using System.ComponentModel;  </p>
</li>
<li><p>using System.Data;  </p>
</li>
<li><p>using System.Drawing;  </p>
</li>
<li><p>using System.Text;  </p>
</li>
<li><p>using System.Windows.Forms;  </p>
</li>
<li><p>using System.IO;  </p>
</li>
<li><p>using Microsoft.Win32;  </p>
</li>
<li><p>namespace Installutil  </p>
</li>
<li><p>{  </p>
</li>
<li><p>public partial class frmInstaller : Form  </p>
</li>
<li><p>{  </p>
</li>
<li><p>#region “ 成员变量 “</p>
</li>
<li><p>private ServiceInstaller _installer;  </p>
</li>
<li><p>privatestring svcName = “WuJianService”;  </p>
</li>
<li><p>privatestring svcDispName = “WuJianServiceDemo”;  </p>
</li>
<li><p>#endregion</p>
</li>
<li><p>#region “ 构造函数 “</p>
</li>
<li><p>public frmInstaller()  </p>
</li>
<li><p>{  </p>
</li>
<li><p>InitializeComponent();  </p>
</li>
<li><p>_installer = new ServiceInstaller();  </p>
</li>
<li><p>}  </p>
</li>
<li><p>#endregion</p>
</li>
<li><p>#region “ 安装服务 “</p>
</li>
<li><p>privatevoid btnInstall_Click(object sender, EventArgs e)  </p>
</li>
<li><p>{  </p>
</li>
<li><p>bool reslut = false;  </p>
</li>
<li><p>foreach (Control control inthis.Controls)  </p>
</li>
<li><p>{  </p>
</li>
<li><p>if (control.Controls.Count &gt; 0)  </p>
</li>
<li><p>{  </p>
</li>
<li><p>foreach (Control ct in control.Controls)  </p>
</li>
<li><p>{  </p>
</li>
<li><p>if (ct.Text.Trim() == “”)  </p>
</li>
<li><p>{  </p>
</li>
<li><p>MessageBox.Show(“请先设置好所有必填设置信息!”, “设置未全提示”);  </p>
</li>
<li><p>return;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
<li><p>try</p>
</li>
<li><p>{  </p>
</li>
<li><p>folderBrowserDialog1.Description = “选择安装目录”;  </p>
</li>
<li><p>folderBrowserDialog1.ShowNewFolderButton = true;  </p>
</li>
<li><p>folderBrowserDialog1.SelectedPath = “C:\&quot;; </p>
</li>
<li><p>DialogResult dr = folderBrowserDialog1.ShowDialog(); </p>
</li>
<li><p>if (dr == DialogResult.OK) </p>
</li>
<li><p>{ </p>
</li>
<li><p>string path = folderBrowserDialog1.SelectedPath; </p>
</li>
<li><p>if (!Directory.Exists(path)) </p>
</li>
<li><p>{ </p>
</li>
<li><p>Directory.CreateDirectory(path); </p>
</li>
<li><p>} </p>
</li>
<li><p>//拷出文件 </p>
</li>
<li><p>File.WriteAllBytes(Path.Combine(path, “WuJian.WindowsServiceDemo.exe”), global::Installutil.Properties.Resources.WuJian_WindowsServiceDemo); </p>
</li>
<li><p>reslut = _installer.InstallService(Path.Combine(path, “WuJian.WindowsServiceDemo.exe”), svcName, svcDispName); </p>
</li>
<li><p>} </p>
</li>
<li><p>} </p>
</li>
<li><p>catch (Exception ex) </p>
</li>
<li><p>{ </p>
</li>
<li><p>MessageBox.Show(“安装过程发生错误,错误提示:” + ex.Message); </p>
</li>
<li><p>} </p>
</li>
<li><p>MessageBox.Show(reslut ? “安装成功,请重启计算机使服务生效!” : “安装失败!”, reslut ? “成功提示” : “失败提示”); </p>
</li>
<li><p>} </p>
</li>
<li><p>#endregion </p>
</li>
<li><p>#region “ 卸载服务 “ </p>
</li>
<li><p>private void btnunInstall_Click(object sender, EventArgs e) </p>
</li>
<li><p>{ </p>
</li>
<li><p>string imagepath = GetImagePath(); </p>
</li>
<li><p>if (imagepath != string.Empty) </p>
</li>
<li><p>{ </p>
</li>
<li><p>bool reslut = _installer.UnInstallService(svcName); </p>
</li>
<li><p>if (reslut &amp;&amp; imagepath != string.Empty) </p>
</li>
<li><p>{ </p>
</li>
<li><p>try </p>
</li>
<li><p>{ </p>
</li>
<li><p>if (File.Exists(imagepath)) </p>
</li>
<li><p>{ </p>
</li>
<li><p>string path = Path.GetDirectoryName(imagepath); </p>
</li>
<li><p>DirectoryInfo di = new DirectoryInfo(path); </p>
</li>
<li><p>di.Delete(true); </p>
</li>
<li><p>} </p>
</li>
<li><p>} </p>
</li>
<li><p>catch { } </p>
</li>
<li><p>} </p>
</li>
<li><p>MessageBox.Show(reslut ? “卸载成功,请重启计算机清除服务!” : “卸载失败!”, “卸载提示”); </p>
</li>
<li><p>} </p>
</li>
<li><p>else </p>
</li>
<li><p>{ </p>
</li>
<li><p>MessageBox.Show(“当前服务未安装，无需卸载！”, “卸载提示”); </p>
</li>
<li><p>} </p>
</li>
<li><p>} </p>
</li>
<li><p>#endregion </p>
</li>
<li><p>#region “ 获取安装目录 “ </p>
</li>
<li><p>private string GetImagePath() </p>
</li>
<li><p>{ </p>
</li>
<li><p>string result = string.Empty; </p>
</li>
<li><p>try </p>
</li>
<li><p>{ </p>
</li>
<li><p>RegistryKey registry = Registry.LocalMachine; </p>
</li>
<li><p>RegistryKey key = registry.OpenSubKey(@”SYSTEM\ControlSet001\Services&quot; + svcName); </p>
</li>
<li><p>if (null != key) </p>
</li>
<li><p>{ </p>
</li>
<li><p>result = key.GetValue(“ImagePath”, (object)string.Empty).ToString();  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
<li><p>catch</p>
</li>
<li><p>{ }  </p>
</li>
<li><p>return result;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>#endregion</p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
</ol>
<p>Install Helper:</p>
<ol>
<li><p>using System;  </p>
</li>
<li><p>using System.Collections.Generic;  </p>
</li>
<li><p>using System.Text;  </p>
</li>
<li><p>using System.Runtime.InteropServices;  </p>
</li>
<li><p>using System.ServiceProcess;  </p>
</li>
<li><p>namespace Installutil  </p>
</li>
<li><p>{  </p>
</li>
<li><p>class ServiceInstaller  </p>
</li>
<li><p>{  </p>
</li>
<li><p>#region public Variables</p>
</li>
<li><p>privateconstint SC_MANAGER_CREATE_SERVICE = 0x0002;  </p>
</li>
<li><p>privateconstint SERVICE_WIN32_OWN_PROCESS = 0x00000010;  </p>
</li>
<li><p>privateconstint SERVICE_DEMAND_START = 0x00000003;  </p>
</li>
<li><p>privateconstint SERVICE_ERROR_NORMAL = 0x00000001;  </p>
</li>
<li><p>privateconstint STANDARD_RIGHTS_REQUIRED = 0xF0000;  </p>
</li>
<li><p>privateconstint SERVICE_QUERY_CONFIG = 0x0001;  </p>
</li>
<li><p>privateconstint SERVICE_CHANGE_CONFIG = 0x0002;  </p>
</li>
<li><p>privateconstint SERVICE_QUERY_STATUS = 0x0004;  </p>
</li>
<li><p>privateconstint SERVICE_ENUMERATE_DEPENDENTS = 0x0008;  </p>
</li>
<li><p>privateconstint SERVICE_START = 0x0010;  </p>
</li>
<li><p>privateconstint SERVICE_STOP = 0x0020;  </p>
</li>
<li><p>privateconstint SERVICE_PAUSE_CONTINUE = 0x0040;  </p>
</li>
<li><p>privateconstint SERVICE_INTERROGATE = 0x0080;  </p>
</li>
<li><p>privateconstint SERVICE_USER_DEFINED_CONTROL = 0x0100;  </p>
</li>
<li><p>privateconstint SERVICE_ALL_ACCESS = (STANDARD_RIGHTS_REQUIRED |  </p>
</li>
<li><p>SERVICE_QUERY_CONFIG |  </p>
</li>
<li><p>SERVICE_CHANGE_CONFIG |  </p>
</li>
<li><p>SERVICE_QUERY_STATUS |  </p>
</li>
<li><p>SERVICE_ENUMERATE_DEPENDENTS |  </p>
</li>
<li><p>SERVICE_START |  </p>
</li>
<li><p>SERVICE_STOP |  </p>
</li>
<li><p>SERVICE_PAUSE_CONTINUE |  </p>
</li>
<li><p>SERVICE_INTERROGATE |  </p>
</li>
<li><p>SERVICE_USER_DEFINED_CONTROL);  </p>
</li>
<li><p>privateconstint SERVICE_AUTO_START = 0x00000002;  </p>
</li>
<li><p>privateconstint GENERIC_WRITE = 0x40000000;  </p>
</li>
<li><p>privateconstint DELETE = 0x10000;  </p>
</li>
<li><p>#endregion</p>
</li>
<li><p>#region DLLImport</p>
</li>
<li><p>[DllImport(“advapi32.dll”)]  </p>
</li>
<li><p>privatestaticextern IntPtr OpenSCManager(string lpMachineName, string lpSCDB, int scParameter);  </p>
</li>
<li><p>[DllImport(“advapi32.dll”)]  </p>
</li>
<li><p>privatestaticextern IntPtr CreateService(IntPtr SC_HANDLE, string lpSvcName, string lpDisplayName,  </p>
</li>
<li><p>int dwDesiredAccess, int dwServiceType, int dwStartType, int dwErrorControl, string lpPathName,  </p>
</li>
<li><p>string lpLoadOrderGroup, int lpdwTagId, string lpDependencies, string lpServiceStartName, string lpPassword);  </p>
</li>
<li><p>[DllImport(“advapi32.dll”)]  </p>
</li>
<li><p>privatestaticexternvoid CloseServiceHandle(IntPtr SCHANDLE);  </p>
</li>
<li><p>[DllImport(“advapi32.dll”)]  </p>
</li>
<li><p>privatestaticexternint StartService(IntPtr SVHANDLE, int dwNumServiceArgs, string lpServiceArgVectors);  </p>
</li>
<li><p>[DllImport(“advapi32.dll”, SetLastError = true)]  </p>
</li>
<li><p>privatestaticextern IntPtr OpenService(IntPtr SCHANDLE, string lpSvcName, int dwNumServiceArgs);  </p>
</li>
<li><p>[DllImport(“advapi32.dll”)]  </p>
</li>
<li><p>privatestaticexternint DeleteService(IntPtr SVHANDLE);  </p>
</li>
<li><p>[DllImport(“kernel32.dll”)]  </p>
</li>
<li><p>privatestaticexternint GetLastError();  </p>
</li>
<li><p>#endregion DLLImport</p>
</li>
<li><p>#region “ 安装和运行 “</p>
</li>
<li><p>/// <summary></summary></p>
</li>
<li><p>/// 安装和运行</p>
</li>
<li><p>/// </p>
</li>
<li><p>/// <param name="svcPath">程序路径.</p>
</li>
<li><p>/// <param name="svcName"> 服务名</p>
</li>
<li><p>/// <param name="svcDispName">服务显示名称.</p>
</li>
<li><p>/// <returns>服务安装是否成功.</returns></p>
</li>
<li><p>publicbool InstallService(string svcPath, string svcName, string svcDispName)  </p>
</li>
<li><p>{  </p>
</li>
<li><p>try</p>
</li>
<li><p>{  </p>
</li>
<li><p>// 获得服务控制管理器句柄</p>
</li>
<li><p>IntPtr sc_handle = OpenSCManager(null, null, SC_MANAGER_CREATE_SERVICE);  </p>
</li>
<li><p>if (sc_handle.ToInt32() != 0)  </p>
</li>
<li><p>{  </p>
</li>
<li><p>//获得服务句柄</p>
</li>
<li><p>IntPtr sv_handle = CreateService(sc_handle, svcName, svcDispName, SERVICE_ALL_ACCESS, SERVICE_WIN32_OWN_PROCESS, SERVICE_AUTO_START, SERVICE_ERROR_NORMAL, svcPath,null, 0, null, null, null);  </p>
</li>
<li><p>if (sv_handle.ToInt32() == 0)  </p>
</li>
<li><p>{  </p>
</li>
<li><p>CloseServiceHandle(sc_handle);  </p>
</li>
<li><p>returnfalse;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>else</p>
</li>
<li><p>{  </p>
</li>
<li><p>//试尝启动服务</p>
</li>
<li><p>int i = StartService(sv_handle, 0, null);  </p>
</li>
<li><p>if (i == 0)  </p>
</li>
<li><p>{  </p>
</li>
<li><p>returnfalse;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>CloseServiceHandle(sc_handle);  </p>
</li>
<li><p>returntrue;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
<li><p>else</p>
</li>
<li><p>{  </p>
</li>
<li><p>returnfalse;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
<li><p>catch</p>
</li>
<li><p>{  </p>
</li>
<li><p>returnfalse;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
<li><p>#endregion</p>
</li>
<li><p>#region “ 反安装服务 “</p>
</li>
<li><p>/// <summary></summary></p>
</li>
<li><p>/// 反安装服务.</p>
</li>
<li><p>/// </p>
</li>
<li><p>/// <param name="svcName">服务名</p>
</li>
<li><p>/// <returns></returns></p>
</li>
<li><p>publicbool UnInstallService(string svcName)  </p>
</li>
<li><p>{  </p>
</li>
<li><p>//</p>
</li>
<li><p>// 打开SCM管理器</p>
</li>
<li><p>//</p>
</li>
<li><p>IntPtr sc_hndl = OpenSCManager(null, null, GENERIC_WRITE);  </p>
</li>
<li><p>if (sc_hndl.ToInt32() != 0)  </p>
</li>
<li><p>{  </p>
</li>
<li><p>//</p>
</li>
<li><p>// 打开驱动所对应的服务</p>
</li>
<li><p>//</p>
</li>
<li><p>IntPtr svc_hndl = OpenService(sc_hndl, svcName, DELETE);  </p>
</li>
<li><p>if (svc_hndl.ToInt32() != 0)  </p>
</li>
<li><p>{  </p>
</li>
<li><p>int i = DeleteService(svc_hndl);  </p>
</li>
<li><p>if (i != 0)  </p>
</li>
<li><p>{  </p>
</li>
<li><p>//</p>
</li>
<li><p>// 关闭驱动所对应的服务</p>
</li>
<li><p>//</p>
</li>
<li><p>CloseServiceHandle(sc_hndl);  </p>
</li>
<li><p>returntrue;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>else</p>
</li>
<li><p>{  </p>
</li>
<li><p>CloseServiceHandle(sc_hndl);  </p>
</li>
<li><p>returnfalse;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
<li><p>else</p>
</li>
<li><p>{ returnfalse; }  </p>
</li>
<li><p>}  </p>
</li>
<li><p>else</p>
</li>
<li><p>{ returnfalse; }  </p>
</li>
<li><p>}  </p>
</li>
<li><p>#endregion</p>
</li>
<li><p>#region “ 判断服务运行 “</p>
</li>
<li><p>privatebool ServiceIsExisted(string serviceName)  </p>
</li>
<li><p>{  </p>
</li>
<li><p>ServiceController[] services = ServiceController.GetServices();  </p>
</li>
<li><p>foreach (ServiceController s in services)  </p>
</li>
<li><p>{  </p>
</li>
<li><p>if (s.ServiceName == serviceName)  </p>
</li>
<li><p>{  </p>
</li>
<li><p>returntrue;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
<li><p>returnfalse;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>#endregion</p>
</li>
<li><p>#region “ 启动服务 “</p>
</li>
<li><p>publicvoid StartService(string serviceName)  </p>
</li>
<li><p>{  </p>
</li>
<li><p>if (ServiceIsExisted(serviceName))  </p>
</li>
<li><p>{  </p>
</li>
<li><p>System.ServiceProcess.ServiceController service = new System.ServiceProcess.ServiceController(serviceName);  </p>
</li>
<li><p>if (service.Status != System.ServiceProcess.ServiceControllerStatus.Running &amp;&amp; service.Status != System.ServiceProcess.ServiceControllerStatus.StartPending)  </p>
</li>
<li><p>{  </p>
</li>
<li><p>service.Start();  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
<li><p>else</p>
</li>
<li><p>{  </p>
</li>
<li><p>System.Windows.Forms.MessageBox.Show(“找不到服务:” + serviceName + “启动失败”, “启动提示”);  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
<li><p>#endregion</p>
</li>
<li><p>#region “ 停止服务 “</p>
</li>
<li><p>publicvoid StopService(string serviceName)  </p>
</li>
<li><p>{  </p>
</li>
<li><p>if (ServiceIsExisted(serviceName))  </p>
</li>
<li><p>{  </p>
</li>
<li><p>System.ServiceProcess.ServiceController service = new System.ServiceProcess.ServiceController(serviceName);  </p>
</li>
<li><p>if (service.Status == System.ServiceProcess.ServiceControllerStatus.Running)  </p>
</li>
<li><p>{  </p>
</li>
<li><p>service.Stop();  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
<li><p>else</p>
</li>
<li><p>{  </p>
</li>
<li><p>System.Windows.Forms.MessageBox.Show(“找不到服务:” + serviceName + “停止失败”, “停止提示”);  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
<li><p>#endregion</p>
</li>
<li><p>}  </p>
</li>
<li><p>}</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://iuu.me/win32apiinstallwindowsservice/" data-id="cjvp22zza0014somh3lcsdpvn" class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/win32API/">win32API</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/windows-service/">windows service</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
        <article id="post-controlwifibywin32api" class="article article-type-post" itemscope="" itemprop="blogPost" data-scroll-reveal="">

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/controlwifibywin32api/">通过win32API管理无线网络</a>
    </h2>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/controlwifibywin32api/" class="article-date">
  <time datetime="2017-05-22T05:57:30.000Z" itemprop="datePublished">2017-05-22</time>
</a>
        
  <div class="article-category">
    <a class="article-category-link" href="/categories/Code/">Code</a>
  </div>

      </div>
    

    <div class="article-entry" itemprop="articleBody">
      

      

      
        <p><img src="https://iuu.me/wp-content/uploads/2017/05/connection-300x169.jpg" alt=""> 许久没登录的百度贴吧，今天偶然去逛了下。私信里面收到了很多小盆友们关于之前一个大学期间写的wifi小工具的一些疑问。 顺便一起解答了吧。 其实原理很简单，无非就是首先建立一个wifi热点，然后把当前Internet的连接共享给这个热点就可以了。 不过在校期间因为校方和电信有合作关系，所以被强制安装了电信的netkeeper来实现pppoe拨号上网。我个人是比较反感这种脱了裤子放屁的绑架形式的，你搞一个软件来代替传统的windows pppoe拨号无非就是给自身利益带来最大化或者来说拿到更高级的监控及控制权。相信各位大部分在校期间都听说过这个臭名昭扬的电信出品的软件。每次拨通上去要先给你推几条广告赚点曝光量，然后禁用了系统本身的ICS共享。这样一来可以杜绝一个帐号被N个人使用的情况，伤害了自身的利益。但是手机是无辜的啊，难不成放着身边的网络不用还要去给移动运营商做贡献。。。后面就写了这个小工具来成就手机刷微博看视频的梦想。 逻辑简单叙述下吧，首先就是检测netkeeper进程，监控心跳包应答内容。出现后通过钩子拿出句柄，把进程杀掉或者暂停都可以。出现心跳包模拟应答给服务器，然后就是开始之前说的那样建立热点巴拉巴拉的。 建立热点的方式可以用console来建立或者通过win32的API来建立均可。 Console:</p>
<ol>
<li>netsh wlan set hostednetwork mode=allow    </li>
<li>netsh wlan set hostednetwork ssid=’testwifi’ key=1234567890    </li>
<li>netsh wlan start hostednetwork    </li>
</ol>
<p>win32API:</p>
<ol>
<li><p>///   </p>
</li>
<li><p>/// 初始化  </p>
</li>
<li><p>///   </p>
</li>
<li><p>privatevoid Init()    </p>
</li>
<li><p>{    </p>
</li>
<li><p>try</p>
</li>
<li><p>{    </p>
</li>
<li><p>WlanUtils.Throw_On_Win32_Error(wlanapi.WlanOpenHandle(wlanapi.WLAN_CLIENT_VERSION_VISTA, IntPtr.Zero, outthis._ServerVersion, refthis._WlanHandle));    </p>
</li>
<li><p>WLAN_NOTIFICATION_SOURCE notifSource;    </p>
</li>
<li><p>WlanUtils.Throw_On_Win32_Error(wlanapi.WlanRegisterNotification(this._WlanHandle, WLAN_NOTIFICATION_SOURCE.All, true, this._notificationCallback, IntPtr.Zero, IntPtr.Zero, out notifSource));    </p>
</li>
<li><p>WLAN_HOSTED_NETWORK_REASON failReason = this.InitSettings();    </p>
</li>
<li><p>if (failReason != WLAN_HOSTED_NETWORK_REASON.wlan_hosted_network_reason_success)    </p>
</li>
<li><p>{    </p>
</li>
<li><p>thrownew Exception(“Init Error WlanHostedNetworkInitSettings: “ + failReason.ToString());    </p>
</li>
<li><p>}    </p>
</li>
<li><p>}    </p>
</li>
<li><p>catch</p>
</li>
<li><p>{    </p>
</li>
<li><p>wlanapi.WlanCloseHandle(this._WlanHandle, IntPtr.Zero);    </p>
</li>
<li><p>throw;    </p>
</li>
<li><p>}    </p>
</li>
<li><p>}    </p>
</li>
<li><p>///   </p>
</li>
<li><p>/// 设置SSID及连接数  </p>
</li>
<li><p>///   </p>
</li>
<li><p>public WLAN_HOSTED_NETWORK_REASON SetConnectionSettings(string hostedNetworkSSID, int maxNumberOfPeers)    </p>
</li>
<li><p>{    </p>
</li>
<li><p>WLAN_HOSTED_NETWORK_REASON failReason;    </p>
</li>
<li><p>WLAN_HOSTED_NETWORK_CONNECTION_SETTINGS settings = new WLAN_HOSTED_NETWORK_CONNECTION_SETTINGS();    </p>
</li>
<li><p>settings.hostedNetworkSSID = WlanUtils.ConvertStringToDOT11_SSID(hostedNetworkSSID);    </p>
</li>
<li><p>settings.dwMaxNumberOfPeers = (uint)maxNumberOfPeers;    </p>
</li>
<li><p>IntPtr settingsPtr = Marshal.AllocHGlobal(Marshal.SizeOf(settings));    </p>
</li>
<li><p>Marshal.StructureToPtr(settings, settingsPtr, false);    </p>
</li>
<li><p>WlanUtils.Throw_On_Win32_Error(    </p>
</li>
<li><p>wlanapi.WlanHostedNetworkSetProperty(    </p>
</li>
<li><p>this._WlanHandle,    </p>
</li>
<li><p>WLAN_HOSTED_NETWORK_OPCODE.wlan_hosted_network_opcode_connection_settings,    </p>
</li>
<li><p>(uint)Marshal.SizeOf(settings), settingsPtr, out failReason, IntPtr.Zero    </p>
</li>
<li><p>)    </p>
</li>
<li><p>);    </p>
</li>
<li><p>return failReason;    </p>
</li>
<li><p>}    </p>
</li>
<li><p>///   </p>
</li>
<li><p>/// 设置密码  </p>
</li>
<li><p>///   </p>
</li>
<li><p>public WLAN_HOSTED_NETWORK_REASON SetSecondaryKey(string passKey)    </p>
</li>
<li><p>{    </p>
</li>
<li><p>WLAN_HOSTED_NETWORK_REASON failReason;    </p>
</li>
<li><p>WlanUtils.Throw_On_Win32_Error(wlanapi.WlanHostedNetworkSetSecondaryKey(this._WlanHandle, (uint)(passKey.Length + 1), passKey, true, true, out failReason, IntPtr.Zero));    </p>
</li>
<li><p>return failReason;    </p>
</li>
<li><p>}    </p>
</li>
<li><p>///   </p>
</li>
<li><p>/// 查询状态   </p>
</li>
<li><p>///   </p>
</li>
<li><p>public WLAN_HOSTED_NETWORK_STATUS QueryStatus()    </p>
</li>
<li><p>{    </p>
</li>
<li><p>WLAN_HOSTED_NETWORK_STATUS status;    </p>
</li>
<li><p>WlanUtils.Throw_On_Win32_Error(wlanapi.WlanHostedNetworkQueryStatus(this._WlanHandle, out status, IntPtr.Zero));    </p>
</li>
<li><p>return status;    </p>
</li>
<li><p>}    </p>
</li>
<li><p>///   </p>
</li>
<li><p>/// 启动热点  </p>
</li>
<li><p>///   </p>
</li>
<li><p>publicvoid StartHostedNetwork()    </p>
</li>
<li><p>{    </p>
</li>
<li><p>try</p>
</li>
<li><p>{    </p>
</li>
<li><p>this.ForceStop();    </p>
</li>
<li><p>var failReason = this.StartUsing();    </p>
</li>
<li><p>if (failReason != WLAN_HOSTED_NETWORK_REASON.wlan_hosted_network_reason_success)    </p>
</li>
<li><p>{    </p>
</li>
<li><p>thrownew Exception(“Could Not Start Hosted Network!\n\n” + failReason.ToString());    </p>
</li>
<li><p>}    </p>
</li>
<li><p>}    </p>
</li>
<li><p>catch</p>
</li>
<li><p>{    </p>
</li>
<li><p>this.ForceStop();    </p>
</li>
<li><p>throw;    </p>
</li>
<li><p>}    </p>
</li>
<li><p>}    </p>
</li>
<li><p>///   </p>
</li>
<li><p>/// 设置ICS共享  </p>
</li>
<li><p>///   </p>
</li>
<li><p>publicstaticvoid EnableInternetConnectionSharing(string Share)    </p>
</li>
<li><p>{    </p>
</li>
<li><p>try</p>
</li>
<li><p>{    </p>
</li>
<li><p>string connectionToShare = Share;    </p>
</li>
<li><p>string sharedForConnection = “无线网络连接 2”;    </p>
</li>
<li><p>var manager = new NetSharingManager();    </p>
</li>
<li><p>var connections = manager.EnumEveryConnection;    </p>
</li>
<li><p>foreach (INetConnection c in connections)    </p>
</li>
<li><p>{    </p>
</li>
<li><p>var props = manager.NetConnectionProps[c];    </p>
</li>
<li><p>var sharingCfg = manager.INetSharingConfigurationForINetConnection[c];    </p>
</li>
<li><p>if (props.Name == connectionToShare)    </p>
</li>
<li><p>{    </p>
</li>
<li><p>sharingCfg.EnableSharing(tagSHARINGCONNECTIONTYPE.ICSSHARINGTYPE_PUBLIC);    </p>
</li>
<li><p>}    </p>
</li>
<li><p>elseif (props.Name == sharedForConnection)    </p>
</li>
<li><p>{    </p>
</li>
<li><p>sharingCfg.EnableSharing(tagSHARINGCONNECTIONTYPE.ICSSHARINGTYPE_PRIVATE);    </p>
</li>
<li><p>}    </p>
</li>
<li><p>}    </p>
</li>
<li><p>}    </p>
</li>
<li><p>catch (Exception c)    </p>
</li>
<li><p>{    </p>
</li>
<li><p>MessageBox.Show(c.Message);    </p>
</li>
<li><p>}    </p>
</li>
<li><p>}</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://iuu.me/controlwifibywin32api/" data-id="cjvp22zyq0007somhcxjr0lpo" class="article-share-link">Share</a>
      
    </footer>

  </div>

  

  

</article>



      
        <article id="post-lambda" class="article article-type-post" itemscope="" itemprop="blogPost" data-scroll-reveal="">

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/lambda/">lambda表达式</a>
    </h2>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/lambda/" class="article-date">
  <time datetime="2017-04-11T02:36:08.000Z" itemprop="datePublished">2017-04-11</time>
</a>
        
  <div class="article-category">
    <a class="article-category-link" href="/categories/Code/">Code</a>
  </div>

      </div>
    

    <div class="article-entry" itemprop="articleBody">
      

      

      
        <p><img src="https://iuu.me/wp-content/uploads/2018/07/lambda-300x300.jpg" alt=""> 最近一直被小学弟追问lambda到底怎么玩的，顺便backup一份出来吧。 Lambda:</p>
<ol>
<li><p>using System;  </p>
</li>
<li><p>using System.Collections.Generic;  </p>
</li>
<li><p>using System.Linq;  </p>
</li>
<li><p>using System.Text;  </p>
</li>
<li><p>namespace Sample.Tech  </p>
</li>
<li><p>{  </p>
</li>
<li><p>publicclass Lambda  </p>
</li>
<li><p>{  </p>
</li>
<li><p>privatedelegatevoid dg1();  </p>
</li>
<li><p>privatedelegatevoid dg2(string str);  </p>
</li>
<li><p>privatevoid Print(string str)  </p>
</li>
<li><p>{  </p>
</li>
<li><p>Console.WriteLine(str);  </p>
</li>
<li><p>}  </p>
</li>
<li><p>publicvoid Demo()  </p>
</li>
<li><p>{  </p>
</li>
<li><p>dg1 test = delegate { Console.WriteLine(“test method of calling the first”); };  </p>
</li>
<li><p>test += () =&gt; { Console.WriteLine(“test method of calling the second”); };  </p>
</li>
<li><p>dg2 test1 = delegate (string str) { Console.WriteLine($”test1 {str} method of calling the first”); };  </p>
</li>
<li><p>test1 += (string str) =&gt; { Console.WriteLine($”test1 {str} method of calling the second”); };  </p>
</li>
<li><p>test1 += (str =&gt; Console.WriteLine($”test1 {str} method of calling the third”));  </p>
</li>
<li><p>test1 += (str =&gt; { Console.WriteLine($”test1 {str} method of calling the four”); });  </p>
</li>
<li><p>test();       //匿名方法</p>
</li>
<li><p>test1(“str”); //匿名方法</p>
</li>
<li><p>Print(“str”); //传统方法</p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://iuu.me/lambda/" data-id="cjvp22zyy000gsomhnny4em22" class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/csharp/">csharp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/lambda/">lambda</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
        <article id="post-consolidateateverystep" class="article article-type-post" itemscope="" itemprop="blogPost" data-scroll-reveal="">

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/consolidateateverystep/">步步为营</a>
    </h2>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/consolidateateverystep/" class="article-date">
  <time datetime="2010-03-21T07:08:00.000Z" itemprop="datePublished">2010-03-21</time>
</a>
        
  <div class="article-category">
    <a class="article-category-link" href="/categories/Moment/">Moment</a>
  </div>

      </div>
    

    <div class="article-entry" itemprop="articleBody">
      

      

      
        <p>——谨以本文、记录我们璀璨的年华。 <img src="https://iuu.me/wp-content/uploads/2018/07/timg.jpg" alt=""> Side. A Gap of expectation 没有期望，才能做到不失望。 岁月是一首苍白无力的歌，歌的名字叫做《我的未来不是梦》。 在年幼的时候，大人们总是好奇的问我们长大以后要做什么，而我们总是信誓旦旦坚定不移的告诉他们， 我们长大要做科学家。 小时候，思想单纯的如同乐百氏37层过滤后的饮用水。而现在，已经形同城市地下多年不见天日的排污管道中那些浑浊的不能在浑浊的水了。浑浑噩噩的你永远也不清楚这水中究竟掺杂了多少不能说的秘密。 幼儿园，学前班，小学，初中，高中。继而是隔着千山万水的大学。 从37层过滤后的饮用水，到大街小巷1元钱一瓶的饮用水，到非饮用的工业水，最后归于漆黑的地下排污系统，与成千上万的水同流合污，浩浩荡荡，怒吼着并奋力奔腾。 上学是我们长大的必修课程，我们问大人们为什么从小就要上学，大人们义正言辞的告诉我们，这跟你从小要吃饭是一个道理。于是从小我们就铭记在心，不上学就形同与不吃饭。会饿坏的。 关于我的在校学习生涯。 我只想说的是。 感谢下我就读的第三所高中——杨高。 杨高的生活是罐子里的糖果，华而不实却又多彩缤纷。 在这所高级中学里，我的生活如同华丽的乐章，听起来美妙无比，精美绝伦。可是如此高雅的音乐，放到火车站的候车大厅里。会让人们感觉多么哗躁。也就是说当你吃早餐的时候让你吃火锅是一样的道理。 在我就读第一所高中遂平一高的时候，我还是一个乖孩子，每天按部就班的上课，学习，认真，听讲。古时候有一句话叫做“暖饱思淫欲”。在我衣食无忧在遂一高平静学习之余，我就开始不安分的思考。为什么我同桌整天喜欢逃课？这个问题跟当年牛顿被苹果砸到脑袋一样，困扰的让我十分纠结。 坐在宽敞明亮的教室第一排，每天上课后我总是会若有若无盯着我身旁空空如也的座位。思考这个座位的主人是否知道他今天跷掉的是什么课。 我们0620班的班主任很有趣。他教历史的。但是思维方式却挺有哲学感觉的。比如排位的时候会让我一个音乐班的学生跟一个美术班的学生坐在一起。似乎这很有一点点的审美观念充斥在其中。就类似于一个听着很霸气很局长的名字，叫梁富贵。而他却是一个教书的。并且是教历史的而且充当我们的班主任。 后来。在同桌的充满严重蛊惑色彩的话语中。开始了我高中有史以来的第一次跷课。 很煞笔的是，当时同桌带着我跷掉了体育课。于是我满怀期待热情充沛的跷课生涯开始了。而且跷课去上体育课。后来经过不完全统计。我跟煞笔同桌一周的体育课高达三十二节。 后来我一次偶然的机会百度了一下跷课要干什么。同桌再拉我去跷课的时候我就满脸不屑的对他说。 地球不适合你，回你的火星去吧。 这里不得不提的是，我班里的一个走读生带我第一次去遂平的网吧。 在他的带领下，我左拐右钻的抹黑老半天。才走出那片类似于藏着潘多拉魔盒的迷宫。真的。遂平的网吧修建的很安全很到位。至少有一天发洪水了，也能缓冲个几分钟才能打湿网吧的地板。 而在双眼终于被光明所解救的时候。我震惊了。说真的，当时我受到惊吓了。整个诺大的网吧唯一的一台液晶显示器。也就是那象征着网吧的吧台收银机。于是这也就间接的为我夜市去驻马店找小强做了铺垫。 在遂平一高就读最大的收获就是我认识了一个我素未谋面的东西。当班主任塞给我一大把花花绿绿的塑料制品后。我惊异的问他。你们这的便签都是塑料的吗？然后他停顿了一秒后告诉我。这是饭票。我摊开手中花花绿绿的饭票。读出上面印刷的文字后。有那么一瞬间我感觉回到了解放前。一张红色塑料纸上方方正正的印刷着：遂平一高餐厅专用。单位面值一两。 遂平一高的寝室惨不忍睹。你有见过CCTV上报道的战争后的伊拉克么。没错。就是它了。当我跟小强一起快乐蹦达劲舞团的时候。同寝的一个孩子得到我帮他申请的一个QQ号码后。乐不思蜀的兴奋了一整夜。当我购买一张《八度空间》带到学校的时候。同学满目惊奇的平静着问我，你好同学，问下周杰伦是谁。 我突然警觉到我被放逐到一个史前文明满目荒夷自以为是与世隔绝的世界。类似闭关锁国的大清王朝。 于是，带着惶恐不安的心情。 我逃到了西高。 Side. B Sadness 真正的悲伤是不能以天来计算的，而是浸透在每时每刻里的。 西高的生活就此一笔带过。 在西高生活的第五天晚读时接到牧羊的一个电话。后被班主任告知，月休了。收拾收拾东西。回家吧。 就这样。荒谬的西高生活至此终结。 有句话是这么说的。生活在为你关闭一扇门的时候同时会为你打开一扇崭新且阳光明媚的窗户。 就这样。我与飞扬的无资产阶级短暂的上班生活华丽开幕。 飞扬跟我都属于无产阶级人士。毫无办法的我们在社会主义制度下开始忍受着资本主义的剥削。地点步行街XX网吧。 其实做一个小小的网管也是挺舒服的一件事。至少在那个时期的我跟飞扬是这样认为的。虽然说天天被剥削。但是根据实践证明，力的作用是相互的。在我们的剥削的同时。我们也在暗地里剥削他们。至少反剥削革命战线里还有一位忠实的支持者。这里必须的要大大的表扬下龙飞同学。平时我们暗地里白吃白喝感觉还是沧海一粟。幸好龙飞同学明智的加入我们的反革命斗争。每日来免费上网白吃白喝比我们上班都要勤快。那时候我们心里真叫一个痛快鲸吞牛饮般快乐的活着。巴不得再多找点这样无私奉献的革命支持者。我最喜欢跟飞扬一起值夜班。他也最爱光明磊落的坐在吧台给别人开卡上网。而我则跟龙飞坐在下面玩的不亦乐乎。当他感觉光明磊落够了就会自觉的下来找我们蹦会劲舞团，打会儿CS。生活天天如此。如痴如醉。 说到这里不得不说飞扬同学的坏习惯。每当夜深人静之时。他就会在劲舞团上发春。恰如其反的是我们上班那个时候是夏天。其实这是一个不好的习惯。真的。夜里不回家在网吧上网的女孩子都不是乖孩子。因为小智同学曾经告诫我。太阳落山之前回家的女孩子才是乖孩子。 关于飞扬同学。似乎大家真的都被他那戴着象征着知识分子的眼睛所蒙蔽了。他曾经追女孩子的速度。可以说是史无前例绝无仅有的。比一夜情都还要速度的你见过么。虽然这个女孩子的名字我还没有忘记。但是为了保护隐私，防止本文被和谐。所以就不说了。曾经记得飞扬给我说。那个女孩子给他说的最煽情的一句话就是“我要让老公见到我最美的一面”。 这句话出现在视频聊天请求被拒绝之后。 龙飞的劲舞团恩恩爱爱。在这里就当被和谐掉了吧。主要原因在于他这个人比较崇尚暴力。我这个人比较老实比较低调。最见不得的就是暴力行为。不过对此风花雪月故事感兴趣，详情可以致电158XXXXXXX。 糜烂娱乐不思进取的生活也就不过如此。也算是成长经历中波折最为扭曲的一笔吧。记录下这些曾经的画面。标记着我们的年轻与向往。虽然不如别人生活中的笔触璀璨。但至少生活的随心所欲。当然故事不仅仅是如此简单明了。很多内容都是不能表述出来的。要和谐、要有爱。 随着飞扬的离职。 时光迈向九月。我怀着坎坷不安与激动难耐的心情。步入杨高的大门。 没有人知道。在阳光明媚的杨高校园之上。 充满了无尽的喜怒哀乐与最为惊喜的礼物。 Side. C Be yourself 先做自己，再爱别人。 时光冉冉。夏末秋初。 杨高生活未拉开序幕之前。就听说牧羊被遣送回家悔过了。 开学报道的第一天。校园中人山人海。充满了无止无尽的青春气息。在学校公告栏处密密麻麻的黑色文字努力着抹杀我的视力。终于我的名字在我不懈的坚持之下。跳跃而出。0716班。班主任郜俊章。当时我很纠结的是上了九年义务教育白上了。第一个字我竟然不认识。这真是我人生中耻辱的一笔。费尽心思搜索了下16班下面的名字。发现没一个熟悉的字眼。哎。真够悲剧的。面对的还是一个陌生到极致的班级。幸运的是在校园内碰到了小智同学。而我随口一句的16班。竟然把他召到了我同桌。更巧合的是。开学第一天进班挨训的还是我俩。当时去学校我就随手在校门口买了一个小本本。而小智竟然背了个巨无霸书包。这让我纠结到了极点，这真是鲜明对比。我成绿叶陪红花了。当小智打开他巨无霸书包的时候。我得意的笑了。里面厚厚的一摞书，除了学习用的没有。其他一应俱全。 生活就是最精彩的剧集。不到最后一刻你就不知道结局。 随着小智我俩的窃窃私语。一个高大霸气而且略带熟悉的身影随着班主任走进班里。当时我就给小智说。这肯定是一个坏孩子。看他那衣着跟头发就知道。小智点头应允。接着那高大霸气的身影走到我们身边的时候无意被我们瞟见了脸庞。当时小智一脸悲痛的对我说。咱俩好好学习的梦想破灭了。这班毁了。我满目同情的拍拍他。咱来这上学真是个错误。 下面提供一下那个高大霸气的身影详细数据。 当时他身着黑色长的盖到屁股的大T恤。野战军穿的山寨迷彩裤。发型就是现在超越贾君鹏的犀利哥的发型。眼神是取代的是犀利哥忧郁的猥琐。 亚伟、男、90后、外观帅气、性格闷骚、拿手绝活深藏不露、政教处给予封号“老油条” 就这样。五彩缤纷的杨高生活就这样抛锚起航了。酸甜苦辣，一应俱全。我们饱含的热情青春。尽情挥洒在这片土地之上。平静的湖面，泛起了点点琦涟。一圈圈的水波，放大碰撞在一起。声势浩然，火树银花。随后归于平静。一片安宁。 在杨高的生活是完全不按照常理出牌的。就算是用一本辞海般厚实的书都会有说不完的故事。前提是这本书在出版审核的时候还没被和谐。 军训是新生开学接受的第一道洗礼。 教官黝黑的脸庞，深邃犀利的目光。掩盖着一颗童心未泯的心。 在军训即将开始之际，我们学校有一位带眼睛的老师站在队伍前面耀武扬威的说明军训的必要性与纪律性。记得在历史课本上一副历史人物插图上我依稀见到过这位老师似曾相似的面庞。遗憾的是历史人物与现实重叠后。一个是正面一个是反面。这似乎隐隐约约的暗示我们水火不容的真理。后来我才知道。那个戴眼镜的老师是我们的政教主任。确实有耀武扬威的资本。 军训在热火朝天的九月操场轰轰烈烈的开始了。操场成为货真价实的操场。 其实军训我感觉很扯淡。就像是早餐吃鸡蛋的时候非让你沾点辣椒酱。让你吃的更香或者说提升你的食欲。但结果往往是这会间接的培养学生们的反抗意识与维权意识或者说是为学校增加点津贴而已。我们花了90块人民币换了一套不合体的一次性假冒伪劣产品。更可气的是衣服上连个商标产地都没有。 我们的教官是一个黝黑壮实浓缩就是精华的小伙子。他的战友都叫他蛋子。这打破了我对部队文艺水平的以往认知。其实部队也挺有内涵的。连昵称都起的这么量身合体。可是我们的蛋子却不让我们这么叫他。其实我们也不乐意这么叫您。毕竟这么不雅的词汇从我们嘴中说出。是多么有损学校的名声的一件事。我们称呼您亲爱的蛋子的时候不就是为了少受点罪嘛。毕竟谁真的乐意花钱买罪受呢。 热火朝天的操场。此起彼伏的斥训声。让我真实的同情在封建统治压迫下的农民。就像课本上说的。哪里有压迫，哪里就会有反抗。 这不，咱的亚伟同学在广大同学们都汗流浃背的在操场晒太阳的时候。他却躲在寝室的洗手间里跟一些起义份子痛快的打水仗。天堂与地狱，仅隔一线之间。于是我明智的选择了天堂。而小智同学也绞尽脑汁的想到了一个叫做甲沟炎的症状。借此间接的来到了天堂。 唯物主义告诉我们，一切的迷信思想最终都会不攻自破的。我们的天堂也包括在此。 那是一个阳光明媚的下午。空气中弥漫着刺人的硝烟味。我们还是快乐的活在天堂。嗅不出一点警觉的味道。或者说我们不长脑子的把硝烟味当作烟花味了。于是我在下楼去厕所的时候被蛋子光荣的抓获我满目悲凉略带同情的看着身边的小智。小智委屈的告诉教官他要去厕所。表情却坚定不移的如同视死如归的董崔瑞。而我则被无条件的被逮捕回了热火朝天的操场。看着长长的被抓回的队伍。倍感温暖，同是天涯沦落人，相逢何必曾相识。漫长的队伍里面，一个猥琐内涵的身影挤进了我的视线。当时我就心一凉。这天堂真的是被人连根拔起了。就在我们排好队伍，准备接受暴风雨般的洗礼的时候。董崔瑞缓缓的走入操场。表情平静目光坚定的一塌糊涂。站到我身边后我不禁深思，革命队伍就需要你这炸药包不离手的人才。都有机会跑路了还是回来扛着炸药包视死如归。 可能是小智的目光以及站立的姿态深深的伤害到了一位教官。让我向前一步，接着飞起一脚踢到了小智的手腕。当时我真的想鼓起勇气告诉教官。您不如改行去国足吧。小智的反应刺瞎了我们围观的眼球。他竟然退后一步，手表一扔。一副视死如归的架势。教官阴森的说想单挑吗？我当时就想你TM的能在火星点吗？让你把手伸到滚烫的油锅里还蛊惑你说着洗洗更健康，这事你乐意么。说实在的，当时我们都挺佩服小智哪来的勇气。后来回寝室了我们才得知真相。我只是怕他踢坏了我的手表。这个结果显然不能被广大人民群众接受。那是一个抑郁的夜晚。彻夜无眠。不仅仅纠结于小智的回答，更纠结的是教官真TM的变态。 整整96个人。每人还被一个小本子留下了名字。我们亲爱的蛋子吹响了他胸前闪亮亮的口哨。怂恿建立了一个庞大的围观体系。全体新生都停止训练，共同见证革命战士英勇就义的时刻。教官们估计是革命题材的连续剧看多了。电视里不都是这么演的么。革命战士倒下前总要大呼一声革命口号。而现场直播的连续剧则更具有戏剧化。他们还准备了一个电视连续剧里见不到的东西。就小摊上卖的那种扩音小喇叭。革命口号则被篡改为我们的姓名。这更像是一场真实的山寨版革命连续剧了。而小智则因为取下手表的保护行为。被光荣的给予2个特写喊话镜头。而间接成为这部山寨版革命连续剧的主角。当然这些都是吸纳观众胃口的前戏。就像西方人吃西餐前都是先来一杯开胃酒。而后才好大快朵颐。教官们经过深思熟虑后，决定让我们玩一个叫做匍匐前进的小游戏。游戏规则很简单，匍匐前进到指定地点。然后再返回。当时我们的想法都很一致。这次真他妈的亏大了。竟然没穿一次性的伪劣军装。更悲剧的是一个女孩委屈的告诉军官她今天穿的是裙子。教官冷漠的一视同仁。一个简单的字“爬”。口气生硬的像一个没有感情色彩的机器人。目光在坚定的掩护下。色眯眯的夺目生辉。当然这些不堪入目的画面同样会被编导剪辑的十全十美。毫无PS痕迹。 军训生活就在这样喧闹中草草收场。当然最后的总结大会中我们这些革命人士会被理所当然的作为代表而独立站成一片。 鹤立鸡群。 Side. D Invent 如果不快乐，就去创造些快乐。 正式开学后的日子平淡无味。 而本文的线索也由亚伟与俊章的第一次正面交锋全面展开。 The First Fight 亚伟 VS 俊章 K.O 犹记得亚伟被俊章K.O后，留下了震古烁今的一句话。“好，你捶我两拳，踢我一脚。我记住了。”附加当时用手指指着俊章的姿态。完全雷同于电视剧中决斗后的场景。 有句很著名的话是这么说来着。长江后浪推前浪。顺应历史发展的潮流，越来越多的朋友融入我们的交际圈。杨高生活正式的开始丰富多彩起来。 真实的写照用这篇文字是记录不完整的。但是又不能大大咧咧的夸夸其谈。毕竟这是我们青春的见证。所以本文中出现不正确的地方。欢迎各位同学的指正批评。 在杨高，我们最熟悉的地方莫过于六号楼跟政教处这两个标志性建筑了。 当然，六号楼是我们大家的共同居所。而政教处则是亚伟的每日签到的地方。而我只是仅仅的陪同而已。大家可以完全忽略不计。说起六号楼，那可谓是一片世外桃源，通俗点来讲叫做香格里拉。六号楼是一个公寓楼。之所以叫做公寓楼是学校为了前期发展建设而设置的独立收费的宿舍楼。而为了让你们付过钱之后虚荣一点就改名叫做公寓楼。当我们入住这所公寓楼的时候。很不巧学校迫于学生人数压力。已经对外免费开放。于是我们理所当然幸灾乐祸的住进了所谓的公寓楼。其实说是公寓楼，不过是平常人家的居民楼格局而已。只不过在纪律方面相比于普通宿舍楼要逊色很多。同样随之而来的问题是卫生环境极差。但是由于种种极其方便我们的原因。或者说是鱼和熊掌不可兼得。我们就这样每天视若无物。六号楼有两名寝管。一名是同学们无所忌惮的小寝管。另外一名是同学们都忌惮不以的大寝管。这就像我们的生活，每天生活在水深火热之中。 痛苦并快乐的活着。 教室里的最后一排似乎在广大人民眼中都是最不争气的一排。可是我们很团结。例如小明与小龙同学每当一提议，心中有所不爽，不如去六号楼面三的时候。大家都是众口一词全票通过。当然虽然我知道这是不对的。但由于我一人难挡众人怒。反抗两次被顺利镇压后。我也自然的水到渠成了。年轻的孩子们都一样。不愿背负如此重担的学习压力。总是找各种理由各种机会来释放压力。但是现实本身就有规则。违反规则必定会受到惩罚。随之而来接二连三的惩罚打的我们措手不及。 最直接的惩罚不是来自皮肉之苦。而是来自政教处。 说起政教处。我对这个学校机构的评价只有4个字。特务机构。譬如明朝时期的锦衣卫来着。整天搞的人心惶惶，鸡飞狗跳。如果你有兴趣想体验下明朝时期的生活。不用穿越不用惊奇。来我们学校就读，即可开启明朝盛大之旅。明朝时期特务机构掩人耳目瞒天过海。我们学校也不甘落寞，全科技武装。摄像头数量堪比国家机密实验室。据悉我们上届的学长们口中流传，曾经学校还在四周围墙上面的铁丝网上安装传感器，以防止学生们私人越狱行为。再一通上电，整一个侏罗纪公园了。门卫更是兼职抓人罚款打折于一身。就跟明朝时期的宦官专权统治是一样的。抓到你的把柄，根本不用通知皇帝等高层。就地正法。开门见山。私了还是公了。私了可以酌情给予折扣并且完事后从此销声匿迹大路朝北各走一方。公了罚款翻倍另送家长免费到校参观券白纸黑字处理布告一张。权衡利弊，破钱消灾还是自寻死路。二选一，机不可失失不再来。 享受到门卫折扣优惠的全杨高估计仅有小智一人。原因只在于小智被抓时泪流满面，并声称要痛改前非，并宣称口袋中仅剩50元钱。门卫一时心软，又观此生面生不熟，且有良好的认罪态度。善良大方的接过小智的50元钱并从口袋中摸索半天掏出了20元钱递给小智。为此小智得意洋洋不厌其烦的给我们复述了长达半个月之久。 学校采取高科技武装的封闭式管理。想出去溜达溜达的学生们无非是翻个墙，但仅仅局限于男生们来说。女生们要出去就得再腐败一点，瞒天过海。 大多数人心中都有一个名字，那个名字的熟悉程度就像我们每天必须携带在身上的大门钥匙。 他的名字叫老贾。 老贾是一个奇才。不得不佩服他的公关能力以及仿制能力。那在杨高可是屈指可数的响当当人才。单逢不说他在学校的公关能力。就仿制影印能力。绝对是独一无二，毫无PS痕迹。老贾别看个头不高。有句话不是叫浓缩的都是精华吗。这就是他本人的现实写照。学校上下除了高层管理外。老贾几乎是上通京城，下通苏杭。从最小权限的寝管，到掌握门禁生死大权的门卫。外加购物优惠折扣的水果店老板。寝室扣分了怎么办，找老贾。想出去溜达怎么办，找老贾。活脱脱的一个华佗再世。你说这要给他放到革命时期。绝对上演一幕震古烁今的无间道。再说说老贾的仿制能力。没有他做不出的。只有你想不到的。就单说老贾手中的空白假条。那可谓是历史的大跃进时期。生产力牛气哄哄的。而且完全的中国制造。只可惜后来老贾同学为情所困，天天借酒消愁，不思进取。一代人才至此陨落。红颜祸水，名不虚传。 话说自从亚伟首次公开与俊章争锋后。俊章是一再二再而三的天天绞尽脑汁的想要整垮这个与他公开争锋的孩子。由于我们与亚伟平日关系非浅，不由的祸水东移。连我们也被纳入整治对象。没事从生活上，学习上。找出种种理由与借口。无理由与借口就人为制造。搞的我们是整日坐卧不宁，坎坷不安。说起俊章，我不得不重点来花费大篇幅来讲述一个人背后的故事。这位班主任老师，是我上学十多年第一次碰到的火星另类。就拿开学第一天训斥了我跟小智后。晚上三节晚自习也是闲来无事。学校安排也就是沟通师生感情之用。而我们班主任也就是俊章。晚上上课后进班第一句话就是我是你们的班主任。进了这个班，我就是皇帝。你们都要无条件服从我的命令。另外奉告一句。教育法和教师守则对我来说都是无效的。当时他说完我跟小智就纠结的要死。在大家的印象中。新班主任新环境第一天应该是首先自我介绍。然后让大家也来个自我介绍。以便沟通师生感情。日后好促进学习，方便管理。可这班主任完全不按照常理出牌。随心所欲，为所欲为。完全颠覆我们对老师的美好印象。接着他便大大咧咧的往讲台上一坐。稳如泰山，夸夸其谈的给我们讲他在杨高就读时的光辉岁月。说什么他在杨高上学的时候，家就在杨高的围墙旁边。平时从他家到校门口需要花费5分钟的时间，而他为了节约时间，不走寻常路。每日上学放学，走墙头路线。说他上学的那个年代，是一个动乱不安的年代。每天上学腰里面不插把刀他都不敢来上学。在学校上学的时候，学校的混混头都照应着他。尊他为贵。据他描述，1号寝楼的寝管曾经就职于我们学校的门卫。当时他心情不好。还与当时的门卫老头干了一架。牛气哄哄的跑出了学校。找到了一个小饭馆，点了4盘菜。叫了瓶不知其名的白酒。一口气就喝了大半瓶。后来菜也没吃，掂着酒瓶就回学校了。其实我现在依旧想知道。他当时一口气喝了大半瓶的白酒后。给小饭馆的老板买单了没有。按照他所描述的。上学的时候腰里面都插了一把刀，又一口气喝了大半瓶白酒。估计这单小饭馆的老板也没吱声。腰里插把刀又一口气喝了大半瓶白酒。这心情也肯定好不到哪去。再上前要求买单。这一刀进去，可就是红刀子出了。讲到如此兴奋之处。他见我们全班都没吱声，对预料的效果估计还是很满意的。然后趁热打铁。又自作主张的先定下苛刻的比资本主义剥削老百姓还要夸张的班规。其中有两条我记忆犹新。一条是上自习课的时候，他比较喜欢我们用心自习，而所要求我们达到的程度。就是在我们自习的时候，他故意站在窗户外面咳咳几声或者故意大力一脚踹开教室门，若是敢有人抬头与他造成实现平行视线对视。那么恭喜你，你将有机会到他隔壁的休息间里与他面对面做深层的沟通。男生的话，就是拳脚相加。女生的话，就是扫帚把子。还有一条是为了我们学习好。就是没事的时候，他随机抽选一名同学到他的休息间内，给你出点数学或者英语题。你要答不出来的话，哼哼，结果是跟上一条同等的公平待遇。后来开始上课的时候大家才明白原来俊章是教政治的。这让我们全班同学产生了一个新的理念，凡是教政治的，我就可以钻空子找漏洞。那教育法与教师守则自然就对我无效了。虽然说他是一位政治老师。可是他却信誓旦旦的说他不会给学生做思想工作。他这个人比较崇尚武力。他说别希望你学习退步了就让我找你谈谈心，说说话。当我找到你的时候。希望你身上的衣服能够尽量的厚实。俊章检查作业的方式也是很火星的与众不同。他不喜欢突击检查。当他想要检查作业的时候总是先给我们一个的期限。或者说是一个筹集资金的缓冲时间。他说XX天后我检查作业。少做一道题那么很简单。就是50块钱。 俊章最火星的不仅仅是在于这些言语上，更多的方面则表现在行为方面。例如俊章的一条牛仔裤加上一双棕色的透气皮鞋。他可以做到如同月球是地球的卫星一样。公转与自转两不误。公转就是过日子。自转就是他从不换他的牛仔裤跟小皮鞋。等他换衣服让你耳目一新的时候，我们就明白了。哦，冬天要来了。还有的就是俊章的面部变化表情。有句话叫做翻脸比翻书还快。用这句话来表达俊章面部变化就太OUT了。整一个可以用翻脸比每小时280千米的动车组还要快。尤其是表现在他们一群老师站在综合楼下说说笑笑的时候，看到亚伟同学过来的时候，本来脸部生动的笑容迅速的扭曲为面无表情。其脸部表情变化所耗费的时间就如同光的每秒29.995万千米的速度是一样的概念的。这么快的表情转化，我真担心有一天他的面部肌肉会过早的萎缩衰亡。那样的话他就可以去演皮影戏了，表情是无可挑剔的一成不变。 排位的时候，俊章总是吊儿郎当的手拿成绩单，依靠门口而立。点到一个进去一个。但是每次都是不合时宜的留下我跟亚伟在门外。然后喜咪咪的对我们说，这个关于座位的问题。不是他说了算，得去争取政教处的意见。由此可见他每次都盼望考完试后赶紧排位，并且沉迷于给我们解释这个时刻。乐在其中。 而每次我们进政教处的时候。就如明知必死无疑，却不得不上战场的士兵一样。在政教处那群老古董面前。你一个不小心都会被他们给抓到把柄，并借题发挥。没事给你变小事，小事给你变大事，变完大事都成了他们的喜事了。每次跟他们对话的时候，我总会误认为我知道核泄漏了却知情不报一样。他们总是想法设法的从你嘴中要得到他们所想要的。用尽一切不伤害感情的手段。例如有一次我跟亚伟、小龙我们三个被带进政教处。他们看到我们三个，彼此对视，微微一笑。给我们三个分开。一人占一个屋并配备三个老师服务我们。一个老师满腔热血义正严词的对我说犯错了还不知错。说什么别以为不老实交代他就不知道了。还借此威胁说给你整个开除劝退之类的。另外一个老师心平气和和颜悦色的对你说犯错了就要勇于承认错误，知错就改就是好孩子。还有一个老师给你列举一些前任犯错如何被处置的例子。一个唱白脸，一个唱红脸，另外一个路人甲。不一会儿，张主任进来神神秘秘的靠近我小声的给我说，让我承认错误。说我承认了就让我回班学习。他要找的不是我，是亚伟跟小龙。我满目委屈鄙夷的对他说，你找他们管我什么事啊。我又没犯错。然后他立刻变声威胁道。别以为我不知道你们犯了错。而小龙那屋就更加戏剧化了。彭老师身为我们07届主管纪律的。自然就是老奸巨猾炉火纯青了。手中拿了两张白纸，对小龙略带惋惜的说道。你还不老实交代吗？这亚伟跟小健都把你给供出来了。小龙趁其不备，一手夺过两张白纸。然后泪流满面的望着彭老师，你当我是瞎子吗？亚伟那屋里，张主任进去就一把掏出其山寨手机。翻出电话本，对亚伟沉重的说道。亚伟，你还不老实认错吗？你看看你丁大伯的求情电话都打过来了。亚伟盯着手机上的电话薄三个大字沉思良久。 政教处的每位老师真的是倍感委屈，屈身在杨高了。他们应该去公安机关帮忙审讯案件或者是去参加吹牛脱口秀节目。王老师的一句话更是雷翻了我跟小龙。俺孩子上的内个大学。校服都是阿迪达斯的。有次我与亚伟被叫到政教处。炉火纯青的彭老师不在。王老师对我和亚伟说。彭老师出去办事还没回来。你俩先在这等着。来先过来给我欢乐斗地主指导下出牌。 时光就这样匆匆然的流逝而过。 分班的时候。俊章在教室里给我们说。一会儿我点名字。点到你们了自己站起来。报文报理都自觉点。有的人即使你想报文，我也有本事帮你修改成理科。所以都自觉内涵点。别在让我浪费时间帮你修改分科自愿。于是很多朋友都被分出了十六班。而我跟亚伟，俊章则是单独对我俩说。你俩看这办吧。要不石头剪子布。你俩只能一个人留在这班。于是亚伟被迫无奈转到了十八班。小明跟小龙分到了12班。高蛋分到了13班。小言子以及他亲爱的老婆一同转去了西高。一个团结的集体表面上就此瓦解。与当年八路军一样的。虽然四分五裂在全国。可是依然英勇无比。 十六班的老成员小闯同学随后光荣的融入我们的交际圈。为我们日后的生活增添了一笔浓厚的色彩。 Side. E Scenery 处在高处，就举目眺望。跌落低处，也静心欣赏。 牧羊同学是我们交际圈中唯一一个在实验班中就读的孩子。可实验班里的孩子却因他而引发了我们在杨高的第一场战争。 战争都是血腥且暴力的。无论任何名义下的战争，总是血流成河，荒尸遍野的。而发起者总是高举正义的大旗做出这些惨绝人寰的事。 当然我们现在所说的战争，只是小孩子们的小打小闹而已。通过那场小打小闹又结识了不少新的朋友。不打不相识嘛。但是我在这里要弘扬的是亚伟同学。他是这场小打小闹没有扩大化的直接原因。因为亚伟的名气跟声望比较浓厚，浑身光辉闪闪，霸气长存。我就记得豆在卫生间里刚上完厕所。提提裤子。很不屑很嚣张的问我认识亚伟吗？我说谁是亚伟，我不认识。然后他神色一喜，叫嚣到这事咱中午在说。结果等我吃过早餐进班的时候亚伟用一种很闷骚很贱的表情问我。你给豆他们打起来啦？今天早上豆还跑我寝室说你们班有个孩子叫什么什么，我问他你认识亚伟吗。他说亚伟算个球。 其实现在想起来这些话，还觉得无比好笑，其实现在来说吧。亚伟你不算个正常的球。你算是一个闷骚点的球。 牧羊这孩子不老实，当时亚伟小智我们说他们班有一个女孩儿，平时都是穿着粉红色衣服。所以我们叫她粉红妹妹。让牧羊给打听打听。结果跟连续剧里一样很好很强大。打听到最后那粉红妹妹被牧羊打听到自己手里面了。还铿锵有力的告诉我们：谢谢你们阿。 朱八同学。朱八同学是跟老贾原先一个班级里的。是一个积极向上，天天学习的好孩子。据说在7班的时候曾经还担任班长职位。说到这，我不得不赞扬一下朱八同学的管理带动能力。有天晚上我与牧羊几个人被连拖带拉的拉进7班看他们班组织的晚会。结果只让进不让出。没办法，最后不得已跳窗而出。我出来的时候平安无事。可牧羊就没这么幸运了。随着牧羊从窗口跳出。唰唰唰，后面又跟出了几条黑影。随后轰隆一声巨响，7班久闭的大门轰然洞开。朱八同学满脸激昂，情绪激动的带领广大7班的男生瞬间把我们围得水泄不通。嗷嗷叫的要怼牧羊本人。我靠。我瞬间的瞎了。暗思，这孩子真嚣张。那份霸气，我至今记忆尤深。后来随着那次，朱八同学也融入了我们的交际圈，伴随着他转来16班。那更是水乳交融。朱八的一大优点就是爱自吹自擂。曾经在杨高贴吧，朱八辞职管理权限后。朱八自己申请了N个马甲。发帖声称要朱吧主赶紧回来吧，贴吧不能没有你。接着朱八开始轮流用自己申请的马甲，朱吧主，赶紧回来吧，贴吧你走了之后成了啥样，我们永远支持你，朱吧主，我爱你，你赶紧归来吧。很巧合的是，那天贴吧人气流量很少，朱吧主自己自吹自擂的一个上午还没人回帖。最后终于神色激动的拉着我，看见了没，人家给我发短信了人家说朱八你赶紧上贴吧看看，人家都让你回来呢。我泰然自若的告诉他，自吹自擂好玩吗？他面不改色的说道好玩，我喜欢。还有一次朱八同学无意猜测到了某贴吧管理权限ID密码，巧合的是某贴吧与他有很深的矛盾。于是朱八喜滋滋的赶忙去某网吧开夜市，乐滋滋的听着小歌，手动删着贴。这一删都是一整夜，我不得不说，人要想做成一件称心如意的事的时候，真可怕。 小言子的离去是我们的一大遗憾，走就走吧。连老婆也带走了。真是走的干净利索。这潜意识就是以后你们就找不到理由让我来看你们了。小言子刚来我们班级的时候正值军训期间。是一个戴着小眼睛的叫孟华的同学与我接待的。俊章让我俩给小言子安顿好，刚给小言子安顿到寝室，屁股还没坐下。小言子赶紧就把五块的红旗渠拿出来。热忱的递到我们面前。我还没接，这孟华都先接过来。然后就一本正经的坐在床上。告诉小言子，这杨高的势力格局。说什么你新来的，看你老实，以后我会照顾着你。这学校还没人敢动我呢。跟着我，保证你吃香喝辣。小言子一脸认真。连忙说是是是。我当时也有一股冲动，吃香喝辣天天有人买单。是个人都乐意的事啊。可他却一本正经的说在学校没人敢动他。我抽的一口烟直接差点给呛着。不是有句俗话叫做，人在世上混，难免会挨棍嘛。我坐在旁边一脸沉静，笑而不语。 李逵你认识不？水浒传里面的黑旋风。我班也有一个人叫做李逵。不过不是他真实名字。而我们班的李逵也是黑不溜秋。活生生的黑旋风。你别问为什么黑就称他为黑旋风。水浒传里面的黑旋风不是天天挥舞着一双铁板斧吗？而我们的李逵这是跳街舞的现代都市人。舞起来也是霍霍生辉。李逵这个人比较有意思，他不让我们叫他李逵。让我们叫他小泽。你听这名字多肉麻啊。跟旧时代大地主呼喊他的小老婆似的。李逵的梦想是街舞。立志要考上韩国的街舞大学。古时候的李逵是一个武者。现代的李逵也是一个舞者。你看这名字多般配啊。不过古时候的李逵比较重情谊。而现代的李逵也是重情谊。不过指的是色加爱情方面的情谊。经常是夜不归宿。我们寝室的人都习以为常了。李逵啊。真的。地越耕越熟，牛越耕越老。 胡小花是我们中自称最善良最有爱的孩子。胡小花不是一个女孩子，而是一个地地道道的伪男。经常是声音柔软，语出惊人。没事逃逃小课，没事撒撒小慌。胡小花值得表扬的地方是一个有情人。与我们班里面的某位女生恋爱了长达6年之久对吧？我也忘记了。反正是一个值得表扬的好孩子，为杨高的有情人做了个标范。谁说爱情不能天长地久的。你知道什么是好孩子吗？像胡小花这样的就是好孩子。每天乖乖的听康妹妹的话。曾经我记得康妹妹每天给胡小花1块5角钱的生活费。看到了吧。你能1块5角钱活上一天吗？当然午餐跟晚餐不在这1块5毛钱的支付范围之内。胡小花同学就是一个地地道道的好孩子。 夏伊同学。虽然说这个女孩子比较伪。但还是偶尔会有一点点淑女形象的。该女孩最大的特征就是跟别人的书过不去。我的书就曾经饱受摧残。当然我说的跟书过不去不在于表明她比较喜欢看书。而是喜欢给别人的书改变下静止状态。通俗点来讲就是把你的书成摞成摞的从书桌上的静止状态，转化为停空不到0.1秒的动态。然后狠狠的摔落到地上的成为静态。有时更是咄咄逼人的用脚再狠狠蹂躏一下。然后伸出自己的两根手指头，口中发出Oh，Year。其实那个时候我一直不明白为什么要用两根手指头摆出V的姿态。后来经过飞扬的提醒，我才明白，那在非正常情况下代表挑衅的姿态，也就是用肢体语言加上口头语言向你表示：我很二，你怎么的。谢谢。Oh，Year。而那种非正常情况也就是静态到动态到静态的转化过程。 而我们的主任就更别具一格了。这里的主任非彼时的主任。这个主任是指亚伟班的主任。也就是我们的小莹同学。小莹同学很容易被满足，其在杨高的最大愿望就是我要走读。至于为什么别人称呼她为妇联主任。我也一直未得其知。社会就是这样，别人怎么喊。你就要怎么喊。否则就会格格不入。这就跟高考是一个道理。你必须无条件的选择它。这是一种潮流，一种趋势。跟上述的道理一样。别人叫它高考，你就也得叫它高考。你若叫它儿戏。那么你就会光荣的出列。然后淘汰。 在我们班中还有这样一位女孩，别人称呼她晨迪同学。而大多数不知情的围观群众则都是称呼她为沉底同学。因为她曾经轰轰烈烈的一手创造了杨高跳楼未遂事件。你有见过比跳楼更牛B的未遂么。政教处曾经写出的布告中提到的某同学企图夜不归宿上网未遂。并且给予留校察看处罚。就让广大围观此布告的同学们纠结了好长一阵子。归结晨迪同学之所以思想消极的原因。在一定程度上是于夏伊同学这个患有自我较二精神病患者是有很大联系的。你可以思考一下。一个比较喜欢自称二的人，跟一个思想消极的人坐成同桌是什么概念。相当于让炸弹与导火索放到一起。然后同归于尽。而大多数倍受各种压力压迫的同学仅仅是没有引爆装置的炸弹。表面内风平浪静。其实内心早已风起云涌。看到这同归于尽的画面更加是蠢蠢欲动。当然，即便是引爆再多的炸弹，也只是冰山一角。对于杨高这个稳若磐石的碉堡来说。那一切都是浮云。有这么一个人。他甘愿做以身作则的黄继光。为保全广大人民群众。甘愿用自己的血肉身躯来阻止炸弹的引爆。而他深爱的这个炸弹仅仅是一个特殊型号的炸弹。而不是泛指所有未引爆的炸弹。而这个人，我们叫他小闯。 Side. F Self loving 谁都需要有人对自己好，哪怕是自己对自己好。 每一个校园里面，最不缺少的就是爱。最廉价的也是爱。 每个人都希望能够找到一个知心的人，借以来驱赶学习生活各种各样的压力。来分享彼此的幸福与快乐。 现在科技日益越新。你的妈妈再也不可能会在给你洗刷书包的时候发现里面的粉红色情书。取而代之的都是你小巧手机中的来无声去无影的短信。 举例亚伟同学就是最受移动公司欢迎的客户。曾经亚伟给北京的收信人姓名一栏上是宝的女孩发短信发的是如醉如痴。从西平到北京。960多公里的距离。1毛钱多便宜多实惠啊。你无论身在何处只要在校园内碰到亚伟。百分之百是一边走路，一边手不停息的发着短信。我们学校有个石头的电线杆位于180cm高度的地方囧了一块。如果可能。每天都让这个倒霉的电线杆随机的出现在亚伟的必经之路上。不出1个月。这石头材料的电线杆会在180cm高度的地方拦腰折断。电线杆门都是小事。亚伟曾经在回学校的三轮车上。一手拿着二锅头一手拿着电话发短信。在高速行驶的三轮车上他以为车已经完成了动势到静止的转变了。一手拉开车门，目光集中紧盯着手机屏幕。一脚便踏空下去。结果是酒和手机都平安无事。唯一有点遗憾的是他摔的惨不忍睹。李宁的裤子被划破了个小口子。为此他痛哭流涕泪流满面自责了好久好久。 而短信门的起因则在于小华离开了杨高。 小华是亚伟的在校的女朋友。是一个漂亮活泼的女孩。而且以前还是初中同学。俗话讲近水楼台先得月。不过，这个月亮是亚伟从别人手中轻轻松松挖过来的。由此可见农民是国民的基础这句话一点不假。 距离远并不可怕。可怕的是心越来越远。当然现实中的爱情，距离远会更可怕的。记得在小华离开杨高的时候，亚伟同学自己一个人买了瓶白酒，买了包花生米。自己孤单可怜的在最后一排桌子下面，一边小饮，一边落泪。脸上的失落显而易见。还有小闯深夜在六号楼接通一个来自广州的电话，自己一个人孤独的躲到二楼的厕所里。一面痛苦流涕，一面哽咽言语。借酒浇愁愁更愁。也许酒精确实能让人短暂的放下所有负担，放下所有压力。躲避到一个无知无觉的短暂空隙。但醒来后的失落感却是不堪言语。但很多人依旧选择如此方式来躲避伤痛。爱情的感觉是两个极端。快乐的时候如若天堂。痛苦的时候如若地狱。水深火热，冰戈铁马。落差如此之大。可是人们就是喜欢乐此不彼的折腾自己。痛苦并快乐的活着。 很多人都说，来到杨高毁灭了自己的一生。 你们这个时候还天真的认为自己是在悬崖勒马么？而岂不知你们现在已经身陨谷底？ 如果当初我一直在遂平一高就读，平静的生活，没有逃课，没有不学习。那么此刻的我。也许比现在好，或者比现在差。但是会直接的造成，没有璀璨岁月。没有缤纷鲜艳。没有你们，更没有小亚。没有现在的我在笔记本上敲打这篇文字。 至少我。不后悔我当初的选择。有得必有失。没有当初的选择，也有没有今天的我。既然选择了。就要坚定不移的走下去。多一份选择，多一份不同的生活。人，说实在的。也就这不到一百年的时间。与其过的平淡无味按部就班。不如过的率真一点。过自己想要的生活。历史不可能改写，时光不可能倒流。与其整天抱怨自己的过失。不如把握机会抓紧现在。至少，不能改变，但还能为过去弥补些什么。 最后，我想要留下一点点空间来记录我自己的生活。 在学习上。虽然我的成绩自转学回来后一向很差劲。当初不肯踏实学习。导致现在花费大量的时间去补课。但我没有用那剩下不到80天的日子来抱怨我平时的不努力与贪玩。而是尽全力去弥补过去的损失。 在生活上。感谢你们。我在杨高的所有朋友们。是你们，带给我杨高生活中的欢颜笑语。是你们，带给我失意走出困境的勇气。很抱歉，在这篇短短的文字当中没有机会一一把你们记录其中。对本文中所有未涉及到的朋友们说句。抱歉。 在爱情上。小萍同学是我在杨高所追求的第一个女孩。很遗憾，这份爱情夭折在摇篮之中。以我的自作多情惨淡收场。当然这里对小智的怂恿以及最后的开导说句感谢。遇到小亚，是我在杨高最为惊喜的礼物。虽然前期有很多因素在奋力阻挠企图扼杀这份爱情。非常荣幸的是。这些因素现在都反而都发挥了其反作用。成为稳固守护这份爱情的基石。为此。表示深深的感谢。最后的最后，对小雯同学说句抱歉。虽然对不起三个字都常常被作为脱身的借口而独立存在。但我还是想对你说。对不起。仅仅表达这三个字的字面意思。 还有曾经在杨高被我们欺负过的朋友们。当时的我们青春的一塌糊涂。天真的认为打架就能解决一切纷争。于是在无意间就伤害了许多人。在这里。我代表我们对你们的伤害。表示对不起。希望你们能够原谅。 Side. End Life journey 人生是有限的，我们所能做的不过是在有生之年，让自己过得高兴些罢了。 *为保护隐私，本文中涉及到的人名均已使用简称。 *本文中未涉及到的朋友，不代表你们不重要，被遗忘。 *预祝我自己二十岁生日快乐。预祝军迎、小莹生日同乐。预祝婷婷生日快乐。预祝亚伟生日快乐。 *本文仅为纪念我们璀璨的青春年华。禁止任何商业目的的转载与传播。请自爱。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://iuu.me/consolidateateverystep/" data-id="cjvp22zyv000csomhe43ub6zu" class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/consolidate-at-every-step/">consolidate at every step</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/juniority/">juniority</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/memories/">memories</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
  </article>
  
  
    <nav class="page-nav">
      
      <a class="extend prev" rel="prev" href="/">Prev page</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
    </nav>
  
</section>
</div>

  <footer class="footer">
  
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
    <li><i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>&copy; 2019 iUU</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>

</main>
<aside class="sidebar">
  <button class="navbar-toggle"></button>

<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/hexo.svg" alt="iUU"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">Home</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">Archives</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">Gallery</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">About</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>

<nav class="navbar navbar-bottom">
  <ul class="nav">
      <li class="nav-item">
          <div class="totop" id="totop">
    <i class="fe fe-rocket"></i>
</div>
      </li>
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>

<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
</aside>
<script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>


  <script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/ocean.js"></script>

</body>
</html>